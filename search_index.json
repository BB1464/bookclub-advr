[["index.html", "Advanced R Book Club Welcome", " Advanced R Book Club The R4DS Online Learning Community 2022-06-22 Welcome Welcome to the bookclub! This is a companion for the book Advanced R by Hadley Wickham (Chapman &amp; Hall, copyright 2019, 9780815384571). This companion is available at r4ds.io/advr. This website is being developed by the R4DS Online Learning Community. Follow along, and join the community to participate. This companion follows the R4DS Online Learning Community Code of Conduct. "],["book-club-meetings.html", "Book club meetings", " Book club meetings Each week, a volunteer will present a chapter from the book (or part of a chapter). This is the best way to learn the material. Presentations will usually consist of a review of the material, a discussion, and/or a demonstration of the principles presented in that chapter. More information about how to present is available in the github repo. Presentations will be recorded, and will be available on the R4DS Online Learning Community YouTube Channel. "],["pace.html", "Pace", " Pace We‚Äôll try to cover 1 chapter/week, but‚Ä¶ ‚Ä¶It‚Äôs ok to split chapters when they feel like too much. We will try to meet every week, but will likely take some breaks for holidays, etc. "],["introduction.html", "Chapter 1 Introduction", " Chapter 1 Introduction Learning objectives: For the entire book: Improve programming skills. Develop a deep understanding of the R language fundamentals. Understand what functional programming means. For this chapter (includes the Welcome and Preface): Recognize the differences between the 1st and 2nd edition of this book. Describe the overall structure of the book. Decide whether this book is right for you. Books suggestions: The Structure and Interpretation of Computer Programs (SICP) Concepts, Techniques and Models of Computer Programming The Pragmatic Programmer "],["whats-new.html", "1.1 What‚Äôs new?", " 1.1 What‚Äôs new? ‚ÄúThe first edition used base R functions almost exclusively, this version of the book expands into more advanced functions provided by other pakages.‚Äù ‚ÄúUse of new packages, particularly rlang, which provides a clean interface to low-level data structures and operations.‚Äù Figure 1.1: Twitter: @hadleywickham - 6 June 2019 "],["overview-of-the-book-structure.html", "1.2 Overview of the book structure", " 1.2 Overview of the book structure The book is composed of five sections. A step by step path towards mastering R techniques. The Foundations is the part in which the R components will be examined. It will help understanding how to use all the basics tools to deal with functions and structures. The Functional programming goes a little more in dept into programming with R, making functions of functions. Describing function factories and operators. The Object-oriented programming - OOP is a five chapter section, all about object oriented systems among S3, R6 and S4. The Metaprogramming section introduces you through the programming layers. Finally, the Techniques section is dedicated to finding and fixing bugs and improving performances. 1.2.1 Foundations Six chapters to learn the foundational components of R. The last chapter ‚Äúconditions‚Äù describe errors, warnings, and messages. 1.2.2 Functional programming This part of the book is dedicated to functions: function factories and operators. 1.2.3 Object-oriented programming OOP is the most dense part of the book, as it mentions about systems which interact with R. 1.2.4 Metaprogramming This is the part of the book where things are blended to the Big Picture. R is a versatile functional language that can be managed and assembled. 1.2.5 Techniques Finally, this is the last section of the book, where debugging is used to measure and improve performance. And how to improve performance by rewriting key functions in C++. "],["resources.html", "1.3 Resources", " 1.3 Resources first edition advanced-r-solutions "],["meeting-videos.html", "1.4 Meeting Videos", " 1.4 Meeting Videos 1.4.1 Cohort 1 (no video recorded) 1.4.2 Cohort 2 1.4.3 Cohort 3 1.4.4 Cohort 4 1.4.5 Cohort 5 1.4.6 Cohort 6 Meeting chat log 00:14:40 SriRam: From Toronto, Civil Engineer. I use R for infrastructure planning/ GIS. Here coz of the ping üòÑ , was not ready with a good computer with mic/audio ! 00:15:20 SriRam: I was with Ryan, Federica on other courses 00:23:21 SriRam: I think the only caution is about Copyright issues 00:31:32 Ryan Metcalf: Citation, giving credit back to source. Great comment SriRam. 00:34:33 SriRam: one = one, in my opinion 00:41:53 Ryan Metcalf: https://docs.google.com/spreadsheets/d/1_WFY82UxAdvP4GUdZ2luh15quwdO1n0Km3Q0tfYuqvc/edit#gid=0 00:48:35 Arthur Shaw: The README has a nice step-by-step process at the bottom: https://github.com/r4ds/bookclub-advr#how-to-present. I&#39;ve not done this myself yet, but it looks fairly straightforward. 00:54:13 lucus w: Thanks Ryan. Probably {usethis} will be easier. It looks straight forward 01:00:02 Moria W.: Thank you for sharing that. This has been good! 01:00:08 Vaibhav Janve: Thank you 01:00:44 Federica Gazzelloni: hi SriRam we are going.. "],["names-and-values.html", "Chapter 2 Names and values", " Chapter 2 Names and values Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1.html", "2.1 SLIDE 1", " 2.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-1.html", "2.2 Meeting Videos", " 2.2 Meeting Videos 2.2.1 Cohort 1 (no video recorded) 2.2.2 Cohort 2 2.2.3 Cohort 3 2.2.4 Cohort 4 2.2.5 Cohort 5 2.2.6 Cohort 6 Meeting chat log LOG "],["vectors.html", "Chapter 3 Vectors", " Chapter 3 Vectors Learning objectives: Learn about different types of vectors Learn how these types relate to one another "],["types-of-vectors.html", "3.1 Types of vectors", " 3.1 Types of vectors The family tree of vectors: Credit: Advanced R by Hadley Wickham Atomic. Elements all the same type. List. Elements are different Types. NULL Null elements. Length zero. "],["atomic-vectors.html", "3.2 Atomic vectors", " 3.2 Atomic vectors 3.2.1 Types The vector family tree revisited. Meet the children of atomic vectors Credit: Advanced R by Hadley Wickham 3.2.2 Length one ‚ÄúScalars‚Äù that consist of a single value. # Logicals lgl1 &lt;- TRUE lgl2 &lt;- T # Doubles # integer, decimal, scientific, or hexidecimal format dbl1 &lt;- 1 dbl2 &lt;- 1.234 dbl3 &lt;- 1.234e0 dbl4 &lt;- 0xcafe # Integers # Note: L denotes an integer int1 &lt;- 1L int2 &lt;- 1.234L int3 &lt;- 1.234e0L int4 &lt;- 0xcafeL # Strings str1 &lt;- &quot;hello&quot; # double quotes str2 &lt;- &#39;hello&#39; # single quotes str3 &lt;- &quot;ŸÖÿ±ÿ≠ÿ®Ÿãÿß&quot; # Unicode str4 &lt;- &quot;\\U0001f605&quot; # sweaty_smile 3.2.3 Longer Several ways to make longer: 1. With single values lgl_vec &lt;- c(TRUE, FALSE) 2. With other vectors c(c(1, 2), c(3, 4)) #&gt; [1] 1 2 3 4 See also {rlang} has vector constructor functions too: rlang::lgl(...) rlang::int(...) rlang::dbl(...) rlang::chr(...) They look to do both more and less than c(). More: Enforce type Splice lists More types: rlang::bytes(), rlang::cpl(...) Less: Stricter rules on names Note: currently has questioning lifecycle badge, since these constructors may get moved to vctrs 3.2.4 Missing values Contagion For most computations, an operation over values that includes a missing value yields a missing value (unless you‚Äôre careful) # contagion 5*NA #&gt; [1] NA sum(c(1, 2, NA, 3)) #&gt; [1] NA # innoculate sum(c(1, 2, NA, 3), na.rm = TRUE) #&gt; [1] 6 Types Each type has its own NA type Logical: NA Integer: NA_integer Double: NA_double Character: NA_character This may not matter in many contexts. But this does matter for operations where types matter like dplyr::if_else(). 3.2.5 Testing What type of vector is.*() it? Test data type: Logical: is.logical() Integer: is.integer() Double: is.double() Character: is.character() What type of object is it? Don‚Äôt test objects with these tools: is.vector() is.atomic() is.numeric() Instead, maybe, use {rlang} rlang::is_vector rlang::is_atomic # vector rlang::is_vector(c(1, 2)) #&gt; [1] TRUE rlang::is_vector(list(1, 2)) #&gt; [1] TRUE # atomic rlang::is_atomic(c(1, 2)) #&gt; [1] TRUE rlang::is_atomic(list(1, &quot;a&quot;)) #&gt; [1] FALSE See more here 3.2.6 Coercion R follows rules for coercion: character ‚Üí double ‚Üí integer ‚Üí logical R can coerce either automatically or explicitly Automatic Two contexts for automatic coercion: Combination Mathematical Combination: str(c(TRUE, &quot;TRUE&quot;)) #&gt; chr [1:2] &quot;TRUE&quot; &quot;TRUE&quot; Mathematical operations # imagine a logical vector about whether an attribute is present has_attribute &lt;- c(TRUE, FALSE, TRUE, TRUE) # number with attribute sum(has_attribute) #&gt; [1] 3 Explicit Use as.*() Logical: as.logical() Integer: as.integer() Double: as.double() Character: as.character() But note that coercions may fail in one of two ways, or both: With warning/error NAs as.integer(c(1, 2, &quot;three&quot;)) #&gt; Warning: NAs introduced by coercion #&gt; [1] 1 2 NA "],["attributes.html", "3.3 Attributes", " 3.3 Attributes What How Why 3.3.1 What Two perspectives: Name-value pairs Metadata Name-value pairs Formally, attributes have a name and a value. Metadata Not data itself But data about the data 3.3.2 How Two operations: Get Set Two cases: Single attribute Multiple attributes Single attribute Use attr() # some object a &lt;- c(1, 2, 3) # set attribute attr(x = a, which = &quot;some_attribute_name&quot;) &lt;- &quot;some attribute&quot; # get attribute attr(x = a, which = &quot;some_attribute_name&quot;) #&gt; [1] &quot;some attribute&quot; Multiple attributes To set multiple attributes, use structure() To get multiple attributes, use attributes() b &lt;- c(4, 5, 6) # set b &lt;- structure( .Data = b, attrib1 = &quot;one&quot;, attrib2 = &quot;two&quot; ) # get str(attributes(b)) #&gt; List of 2 #&gt; $ attrib1: chr &quot;one&quot; #&gt; $ attrib2: chr &quot;two&quot; 3.3.3 Why Two common use cases: Names Dimensions Names Three Four ways to name: # 1. At creation one &lt;- c(one = 1, two = 2, three = 3) # 2. By assigning a character vector of names two &lt;- c(1, 2, 3) names(two) &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;) # 3. By setting names--with base R three &lt;- c(1, 2, 3) stats::setNames( object = three, nm = c(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;) ) #&gt; One Two Three #&gt; 1 2 3 # 4. By setting names--with {rlang} rlang::set_names( x = three, nm = c(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;) ) #&gt; One Two Three #&gt; 1 2 3 Thematically but not directly related: labelled class vectors with haven::labelled() Dimensions Important for arrays and matrices. # length 6 vector spread across 2 rows of 3 columns matrix(1:6, nrow = 2, ncol = 3) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 "],["s3-atomic-vectors.html", "3.4 S3 atomic vectors", " 3.4 S3 atomic vectors The vector family tree revisited. Meet the children of typed atomic vectors Credit: Advanced R by Hadley Wickham This list could (more easily) be expanded to new vector types with {vctrs}. See rstudio::conf(2019) talk on the package around 18:27. See also rstudio::conf(2020) talk on new vector types for dealing with non-decimal currencies. What makes S3 atomic vectors different than their parents? Two things: Class Attributes (typically) 3.4.1 Factors Factors are integer vectors with: Class: ‚Äúfactor‚Äù Attributes: ‚Äúlevels‚Äù, or the set of allowed values # Build a factor a_factor &lt;- factor( # values x = c(1, 2, 3), # exhaustive list of values levels = c(1, 2, 3, 4) ) # Inspect a_factor #&gt; [1] 1 2 3 #&gt; Levels: 1 2 3 4 # Dissect # - type typeof(a_factor) #&gt; [1] &quot;integer&quot; # - attributes attributes(a_factor) #&gt; $levels #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; #&gt; #&gt; $class #&gt; [1] &quot;factor&quot; Factors can be ordered. This can be useful for models or visaulations where order matters. # Build ordered_factor &lt;- ordered( # values x = c(1, 2, 3), # levels in ascending order levels = c(4, 3, 2, 1) ) # Inspect ordered_factor #&gt; [1] 1 2 3 #&gt; Levels: 4 &lt; 3 &lt; 2 &lt; 1 3.4.2 Dates Dates are: Double vectors With class ‚ÄúDate‚Äù The double component represents the number of days since since 1970-01-01 notes_date &lt;- Sys.Date() # type typeof(notes_date) #&gt; [1] &quot;double&quot; # class attributes(notes_date) #&gt; $class #&gt; [1] &quot;Date&quot; 3.4.3 Date-times There are 2 Date-time representations in base R: POSIXct, where ‚Äúct‚Äù denotes calendar time POSIXlt, where ‚Äúlt‚Äù designates local time. Let‚Äôs focus on POSIXct because: Simplest Built on an atomic vector Most apt to be in a data frame Let‚Äôs now build and deconstruct a Date-time # Build note_date_time &lt;- as.POSIXct( # time x = Sys.time(), # time zone, used only for formatting tz = &quot;EDT&quot; ) # Inspect note_date_time #&gt; [1] &quot;2022-06-22 14:51:37 UTC&quot; # Dissect # - type typeof(note_date_time) #&gt; [1] &quot;double&quot; # - attributes attributes(note_date_time) #&gt; $class #&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot; 3.4.4 Durations Durations are: Double vectors Class: ‚Äúdifftime‚Äù Attributes: ‚Äúunits‚Äù, or the unit of duration (e.g., weeks, hours, minutes, seconds, etc.) # Construct one_minute &lt;- as.difftime(1, units = &quot;mins&quot;) # Inspect one_minute #&gt; Time difference of 1 mins # Dissect # - type typeof(one_minute) #&gt; [1] &quot;double&quot; # - attributes attributes(one_minute) #&gt; $class #&gt; [1] &quot;difftime&quot; #&gt; #&gt; $units #&gt; [1] &quot;mins&quot; See also: lubridate::make_difftime() clock::date_time_build() "],["lists.html", "3.5 Lists", " 3.5 Lists Sometimes called a generic vector, a list can be composed of elements of different types. 3.5.1 Constructing Simple lists: # Construct simple_list &lt;- list( # logicals c(TRUE, FALSE), # integers 1:20, # doubles c(1.2, 2.3, 3.4), # characters c(&quot;primo&quot;, &quot;secundo&quot;, &quot;tercio&quot;) ) # Inspect # - type typeof(simple_list) #&gt; [1] &quot;list&quot; # - structure str(simple_list) #&gt; List of 4 #&gt; $ : logi [1:2] TRUE FALSE #&gt; $ : int [1:20] 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ : num [1:3] 1.2 2.3 3.4 #&gt; $ : chr [1:3] &quot;primo&quot; &quot;secundo&quot; &quot;tercio&quot; Nested lists: nested_list &lt;- list( # first level list( # second level list( # third level list(1) ) ) ) str(nested_list) #&gt; List of 1 #&gt; $ :List of 1 #&gt; ..$ :List of 1 #&gt; .. ..$ :List of 1 #&gt; .. .. ..$ : num 1 Like JSON. Combined lists # with list() list_comb1 &lt;- list(list(1, 2), list(3, 4)) # with c() list_comb2 &lt;- c(list(1, 2), list(3, 4)) # compare structure str(list_comb1) #&gt; List of 2 #&gt; $ :List of 2 #&gt; ..$ : num 1 #&gt; ..$ : num 2 #&gt; $ :List of 2 #&gt; ..$ : num 3 #&gt; ..$ : num 4 str(list_comb2) #&gt; List of 4 #&gt; $ : num 1 #&gt; $ : num 2 #&gt; $ : num 3 #&gt; $ : num 4 3.5.2 Testing Check that is a list: is.list() `rlang::is_list()`` The two do the same, except that the latter can check for the number of elements # is list base::is.list(list_comb2) #&gt; [1] TRUE rlang::is_list(list_comb2) #&gt; [1] TRUE # is list of 4 elements rlang::is_list(x = list_comb2, n = 4) #&gt; [1] TRUE # is a vector (of a special type) # remember the family tree? rlang::is_vector(list_comb2) #&gt; [1] TRUE 3.5.3 Coercion "],["data-frames-and-tibbles.html", "3.6 Data frames and tibbles", " 3.6 Data frames and tibbles The vector family tree revisited. Meet the children of lists Credit: Advanced R by Hadley Wickham 3.6.1 Data frame A data frame is a: Named list of vectors (i.e., column names) Class: ‚Äúdata frame‚Äù Attributes: (column) names `row.names`` # Construct df &lt;- data.frame( # named atomic vector col1 = c(1, 2, 3), # another named atomic vector col2 = c(&quot;un&quot;, &quot;deux&quot;, &quot;trois&quot;), # not necessary after R 4.1 (?) stringsAsFactors = FALSE ) # Inspect df #&gt; col1 col2 #&gt; 1 1 un #&gt; 2 2 deux #&gt; 3 3 trois # Deconstruct # - type typeof(df) #&gt; [1] &quot;list&quot; # - attributes attributes(df) #&gt; $names #&gt; [1] &quot;col1&quot; &quot;col2&quot; #&gt; #&gt; $class #&gt; [1] &quot;data.frame&quot; #&gt; #&gt; $row.names #&gt; [1] 1 2 3 Unlike other lists, the length of each vector must be the same (i.e.¬†as many vector elements as rows in the data frame). 3.6.2 Tibble As compared to data frames, tibbles are data frames that are: Lazy Surly 3.6.2.1 Lazy Tibbles do not: Coerce strings Transform non-syntactic names Recycle vectors of length greater than 1 Coerce strings chr_col &lt;- c(&quot;don&#39;t&quot;, &quot;factor&quot;, &quot;me&quot;, &quot;bro&quot;) # data frame df &lt;- data.frame( a = chr_col, # in R 4.1 and earlier, this was the default stringsAsFactors = TRUE ) # tibble tbl &lt;- tibble::tibble( a = chr_col ) # contrast the structure str(df$a) #&gt; Factor w/ 4 levels &quot;bro&quot;,&quot;don&#39;t&quot;,..: 2 3 4 1 str(tbl$a) #&gt; chr [1:4] &quot;don&#39;t&quot; &quot;factor&quot; &quot;me&quot; &quot;bro&quot; Transform non-syntactic names # data frame df &lt;- data.frame( `1` = c(1, 2, 3) ) # tibble tbl &lt;- tibble::tibble( `1` = c(1, 2, 3) ) # contrast the names names(df) #&gt; [1] &quot;X1&quot; names(tbl) #&gt; [1] &quot;1&quot; Recycle vectors of length greater than 1 # data frame df &lt;- data.frame( col1 = c(1, 2, 3, 4), col2 = c(1, 2) ) # tibble tbl &lt;- tibble::tibble( col1 = c(1, 2, 3, 4), col2 = c(1, 2) ) #&gt; Error: #&gt; ! Tibble columns must have compatible sizes. #&gt; ‚Ä¢ Size 4: Existing data. #&gt; ‚Ä¢ Size 2: Column `col2`. #&gt; ‚Ñπ Only values of size one are recycled. 3.6.2.2 Surly Tibbles do only what they‚Äôre asked and complain if what they‚Äôre asked doesn‚Äôt make sense: Subsetting always yields a tibble Complains if cannot find column Subsetting always yields a tibble # data frame df &lt;- data.frame( col1 = c(1, 2, 3, 4) ) # tibble tbl &lt;- tibble::tibble( col1 = c(1, 2, 3, 4) ) # contrast df_col &lt;- df[, &quot;col1&quot;] str(df_col) #&gt; num [1:4] 1 2 3 4 tbl_col &lt;- tbl[, &quot;col1&quot;] str(tbl_col) #&gt; tibble [4 √ó 1] (S3: tbl_df/tbl/data.frame) #&gt; $ col1: num [1:4] 1 2 3 4 # to select a vector, do one of these instead tbl_col_1 &lt;- tbl[[&quot;col1&quot;]] str(tbl_col_1) #&gt; num [1:4] 1 2 3 4 tbl_col_2 &lt;- dplyr::pull(tbl, col1) str(tbl_col_2) #&gt; num [1:4] 1 2 3 4 Complains if cannot find column names(df) #&gt; [1] &quot;col1&quot; df$col #&gt; [1] 1 2 3 4 names(tbl) #&gt; [1] &quot;col1&quot; tbl$col #&gt; Warning: Unknown or uninitialised column: `col`. #&gt; NULL 3.6.3 Testing Whether data frame: is.data.frame(). Note: both data frame and tibble are data frames. Whether tibble: tibble::is_tibble. Note: only tibbles are tibbles. Vanilla data frames are not. 3.6.4 Coercion To data frame: as.data.frame() To tibble: tibble::as_tibble() "],["null.html", "3.7 NULL", " 3.7 NULL Special type of object that: Length 0 Cannot have attributes typeof(NULL) #&gt; [1] &quot;NULL&quot; #&gt; [1] &quot;NULL&quot; length(NULL) #&gt; [1] 0 #&gt; [1] 0 x &lt;- NULL attr(x, &quot;y&quot;) &lt;- 1 #&gt; Error in attr(x, &quot;y&quot;) &lt;- 1: attempt to set an attribute on NULL "],["meeting-videos-2.html", "3.8 Meeting Videos", " 3.8 Meeting Videos 3.8.1 Cohort 1 3.8.2 Cohort 2 3.8.3 Cohort 3 3.8.4 Cohort 4 3.8.5 Cohort 5 3.8.6 Cohort 6 Meeting chat log LOG "],["subsetting.html", "Chapter 4 Subsetting", " Chapter 4 Subsetting Learning objectives: Learn about the 6 ways to subset atomic vectors Learn about the 3 subsetting operators: [[, [, and $ Learn how subsetting works with different vector types "],["selecting-multiple-elements.html", "4.1 Selecting multiple elements", " 4.1 Selecting multiple elements 4.1.1 Atomic Vectors 6 ways to subset atomic vectors Let‚Äôs take a look with an example vector. x &lt;- c(3.1, 2.2, 1.3, 4.4) Positive integers # return elements at specified positions x[c(4, 1)] #&gt; [1] 4.4 3.1 # duplicate indices return duplicate values x[c(2, 2)] #&gt; [1] 2.2 2.2 # real numbers truncate to integers x[c(3.2, 3.8)] #&gt; [1] 1.3 1.3 Negative integers ### excludes elements at specified positions # x[-c(1, 3)] # same as x[c(-1, -3)] ### mixing positive and negative is a no-no # x[c(-1, 3)] Logical Vectors x[c(TRUE, TRUE, FALSE, TRUE)] #&gt; [1] 3.1 2.2 4.4 x[x &lt; 3] #&gt; [1] 2.2 1.3 Recyling rules apply when subsetting this way: x[y] Easy to understand if x or y is 1, best to avoid other lengths # missing value in index will also return NA in output x[c(NA, TRUE)] #&gt; [1] NA 2.2 NA 4.4 Nothing # returns the original vector x[] #&gt; [1] 3.1 2.2 1.3 4.4 Zero # returns a zero-length vector x[0] #&gt; numeric(0) Character vectors # if name, you can use to return matched elements (y &lt;- setNames(x, letters[1:4])) #&gt; a b c d #&gt; 3.1 2.2 1.3 4.4 y[c(&quot;d&quot;, &quot;b&quot;, &quot;a&quot;)] #&gt; d b a #&gt; 4.4 2.2 3.1 4.1.2 Lists Subsetting works the same way [ always returns a list, [[ and $ let you pull elements out of a list 4.1.3 Matrices and arrays You can subset higher dimensional structures in three ways: - with multiple vectors - with a single vector - with a matrix a &lt;- matrix(1:9, nrow = 3) colnames(a) &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) a[1:2, ] #&gt; A B C #&gt; [1,] 1 4 7 #&gt; [2,] 2 5 8 a[c(TRUE, FALSE, TRUE), c(&quot;B&quot;, &quot;A&quot;)] #&gt; B A #&gt; [1,] 4 1 #&gt; [2,] 6 3 a[0, -2] #&gt; A C a[1, ] #&gt; A B C #&gt; 1 4 7 a[1, 1] #&gt; A #&gt; 1 Credit: Advanced R by Hadley Wickham Matrices and arrays are just special vectors; can subset with a single vector (arrays in R stored column wise) vals &lt;- outer(1:5, 1:5, FUN = &quot;paste&quot;, sep = &quot;,&quot;) vals #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] &quot;1,1&quot; &quot;1,2&quot; &quot;1,3&quot; &quot;1,4&quot; &quot;1,5&quot; #&gt; [2,] &quot;2,1&quot; &quot;2,2&quot; &quot;2,3&quot; &quot;2,4&quot; &quot;2,5&quot; #&gt; [3,] &quot;3,1&quot; &quot;3,2&quot; &quot;3,3&quot; &quot;3,4&quot; &quot;3,5&quot; #&gt; [4,] &quot;4,1&quot; &quot;4,2&quot; &quot;4,3&quot; &quot;4,4&quot; &quot;4,5&quot; #&gt; [5,] &quot;5,1&quot; &quot;5,2&quot; &quot;5,3&quot; &quot;5,4&quot; &quot;5,5&quot; vals[c(3, 15)] #&gt; [1] &quot;3,1&quot; &quot;5,3&quot; 4.1.4 Data frames and tibbles Data frames act like lists and matrices - single index -&gt; list - two indices -&gt; matrix library(palmerpenguins) # single index penguins[1:2] #&gt; # A tibble: 344 √ó 2 #&gt; species island #&gt; &lt;fct&gt; &lt;fct&gt; #&gt; 1 Adelie Torgersen #&gt; 2 Adelie Torgersen #&gt; 3 Adelie Torgersen #&gt; 4 Adelie Torgersen #&gt; 5 Adelie Torgersen #&gt; 6 Adelie Torgersen #&gt; 7 Adelie Torgersen #&gt; 8 Adelie Torgersen #&gt; 9 Adelie Torgersen #&gt; 10 Adelie Torgersen #&gt; # ‚Ä¶ with 334 more rows penguins[c(&quot;species&quot;,&quot;island&quot;)] #&gt; # A tibble: 344 √ó 2 #&gt; species island #&gt; &lt;fct&gt; &lt;fct&gt; #&gt; 1 Adelie Torgersen #&gt; 2 Adelie Torgersen #&gt; 3 Adelie Torgersen #&gt; 4 Adelie Torgersen #&gt; 5 Adelie Torgersen #&gt; 6 Adelie Torgersen #&gt; 7 Adelie Torgersen #&gt; 8 Adelie Torgersen #&gt; 9 Adelie Torgersen #&gt; 10 Adelie Torgersen #&gt; # ‚Ä¶ with 334 more rows # two indices penguins[1:2, ] #&gt; # A tibble: 2 √ó 8 #&gt; species island bill_length_mm bill_depth_mm flipper_length_‚Ä¶ body_mass_g sex #&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; #&gt; 1 Adelie Torge‚Ä¶ 39.1 18.7 181 3750 male #&gt; 2 Adelie Torge‚Ä¶ 39.5 17.4 186 3800 fema‚Ä¶ #&gt; # ‚Ä¶ with 1 more variable: year &lt;int&gt; Subsetting a tibble with [ always returns a tibble 4.1.5 Preserving dimensionality Data frames and tibbles behave differently tibble will default to preserve dimensionality, data frames do not this can lead to unexpected behavior and code breaking in the future Can use drop = FALSE when using a data frame or can use tibbles "],["selecting-a-single-element.html", "4.2 Selecting a single element", " 4.2 Selecting a single element [[ and $ are used to extract single elements 4.2.1 [[]] x &lt;- list(1:3, &quot;a&quot;, 4:6) Credit: Advanced R by Hadley Wickham 4.2.2 $ x$y is equivalent to x[[\"y\"]] the $ operator doens‚Äôt work with stored vals var &lt;- &quot;cyl&quot; # Doesn&#39;t work - mtcars$var translated to mtcars[[&quot;var&quot;]] mtcars$var #&gt; NULL # Instead use [[ mtcars[[var]] #&gt; [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4 $ allows partial matching, [[]] does not x &lt;- list(abc = 1) x$a #&gt; [1] 1 x[[&quot;a&quot;]] #&gt; NULL Hadley advises to change Global settings: options(warnPartialMatchDollar = TRUE) x$a #&gt; Warning in x$a: partial match of &#39;a&#39; to &#39;abc&#39; #&gt; [1] 1 tibbles don‚Äôt have this behavior penguins$s #&gt; Warning: Unknown or uninitialised column: `s`. #&gt; NULL 4.2.3 missing and out of bound indices Due to the inconsistency of how R handles such indices, purrr::pluck() and purrr::chuck() are recommended x &lt;- list( a = list(1, 2, 3), b = list(3, 4, 5) ) purrr::pluck(x, &quot;a&quot;, 1) # [1] 1 purrr::pluck(x, &quot;c&quot;, 1) # NULL purrr::pluck(x, &quot;c&quot;, 1, .default = NA) # [1] NA 4.2.4 @ and slot() @ is $ for S4 objects (to be revisited in Chapter 15) slot() is [[ ]] for S4 objects "],["subsetting-and-assignment.html", "4.3 Subsetting and Assignment", " 4.3 Subsetting and Assignment Subsetting can be combined with assignment to edit values x &lt;- c(&quot;Tigers&quot;, &quot;Royals&quot;, &quot;White Sox&quot;, &quot;Twins&quot;, &quot;Indians&quot;) x[5] &lt;- &quot;Guardians&quot; x #&gt; [1] &quot;Tigers&quot; &quot;Royals&quot; &quot;White Sox&quot; &quot;Twins&quot; &quot;Guardians&quot; length of the subset and assignment vector should be the same to avoid recycling You can use NULL to remove a component x &lt;- list(a = 1, b = 2) x[[&quot;b&quot;]] &lt;- NULL str(x) #&gt; List of 1 #&gt; $ a: num 1 Subsetting with nothing can preserve structure of original object # mtcars[] &lt;- lapply(mtcars, as.integer) # is.data.frame(mtcars) # [1] TRUE # mtcars &lt;- lapply(mtcars, as.integer) #&gt; is.data.frame(mtcars) # [1] FALSE "],["applications.html", "4.4 Applications", " 4.4 Applications Applications copied from cohort 2 slide 4.4.1 Lookup tables (character subsetting) x &lt;- c(&quot;m&quot;, &quot;f&quot;, &quot;u&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;, &quot;m&quot;) lookup &lt;- c(m = &quot;Male&quot;, f = &quot;Female&quot;, u = NA) lookup[x] # m f u f f m m # &quot;Male&quot; &quot;Female&quot; NA &quot;Female&quot; &quot;Female&quot; &quot;Male&quot; &quot;Male&quot; 4.4.2 Matching and merging by hand (integer subsetting) The match() function allows merging a vector with a table grades &lt;- c(&quot;D&quot;, &quot;A&quot;, &quot;C&quot;, &quot;B&quot;, &quot;F&quot;) info &lt;- data.frame( grade = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;F&quot;), desc = c(&quot;Excellent&quot;, &quot;Very Good&quot;, &quot;Average&quot;, &quot;Fair&quot;, &quot;Poor&quot;), fail = c(F, F, F, F, T) ) id &lt;- match(grades, info$grade) id # [1] 3 2 2 1 3 info[id, ] # grade desc fail # 4 D Fair FALSE # 1 A Excellent FALSE # 3 C Average FALSE # 2 B Very Good FALSE # 5 F Poor TRUE 4.4.3 Random samples and bootstrapping (integer subsetting) # mtcars[sample(nrow(mtcars), 3), ] # use replace = TRUE to replace # mpg cyl disp hp drat wt qsec vs am gear carb # Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 # Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 # Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 4.4.4 Ordering (integer subsetting) # mtcars[order(mtcars$mpg), ] # mpg cyl disp hp drat wt qsec vs am gear carb # Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 # Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 # Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 # Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 # Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 # Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 # ... 4.4.5 Expanding aggregated counts (integer subsetting) We can expand a count column by using rep() df &lt;- tibble::tibble(x = c(&quot;Amy&quot;, &quot;Julie&quot;, &quot;Brian&quot;), n = c(2, 1, 3)) df[rep(1:nrow(df), df$n), ] # A tibble: 6 x 2 # x n # &lt;chr&gt; &lt;dbl&gt; # 1 Amy 2 # 2 Amy 2 # 3 Julie 1 # 4 Brian 3 # 5 Brian 3 # 6 Brian 3 4.4.6 Removing columns from data frames (character) We can remove a column by subsetting, which does not change the object df[, 1] # A tibble: 3 x 1 # x # &lt;chr&gt; # 1 Amy # 2 Julie # 3 Brian We can also delete the column using NULL df$n &lt;- NULL df # A tibble: 3 x 1 # x # &lt;chr&gt; # 1 Amy # 2 Julie # 3 Brian 4.4.7 Selecting rows based on a condition (logical subsetting) # mtcars[mtcars$gear == 5, ] # mpg cyl disp hp drat wt qsec vs am gear carb # Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.7 0 1 5 2 # Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 # Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.5 0 1 5 4 # Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.5 0 1 5 6 # Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.6 0 1 5 8 4.4.8 Boolean algebra versus sets (logical and integer) which() gives the indices of a Boolean vector (x1 &lt;- 1:10 %% 2 == 0) # 1-10 divisible by 2 # [1] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE (x2 &lt;- which(x1)) # [1] 2 4 6 8 10 (y1 &lt;- 1:10 %% 5 == 0) # 1-10 divisible by 5 # [1] FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE TRUE (y2 &lt;- which(y1)) # [1] 5 10 x1 &amp; y1 # [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE "],["meeting-videos-3.html", "4.5 Meeting Videos", " 4.5 Meeting Videos 4.5.1 Cohort 1 4.5.2 Cohort 2 4.5.3 Cohort 3 4.5.4 Cohort 4 4.5.5 Cohort 5 4.5.6 Cohort 6 Meeting chat log LOG "],["control-flow.html", "Chapter 5 Control flow", " Chapter 5 Control flow Learning objectives: What are the tools for controlling a flow What is the difference between choices (if, switch) and loops (for, while) How to use conditional tools in data analysis "],["introduction-1.html", "5.1 Introduction", " 5.1 Introduction In this chapter we will see how to use conditions for making data analysis. There are two main group of conditional tools: choices and loops. These are both very useful for making iterating data analysis such as multiple substitutions matching predefined inputs or performing more or less flexible indexing. "],["choices-and-loops.html", "5.2 Choices and Loops", " 5.2 Choices and Loops Iterators of objects pointing to an element inside the container Use if to specify a block of code to be executed, if a specified condition is true. Use else to specify a block of code to be executed, if the same condition is false. Use else if to specify a new condition to test, if the first condition is false. "],["choises.html", "5.3 Choises", " 5.3 Choises if() and ifelse() if (condition) true_action if (condition) true_action else false_action if (test_expression) { yes } if (test_expression) { yes } else if (other test_expression) { no } else { other } --- ifelse(test, yes, no) Note: What is the difference? dplyr::if_else() and base R ifelse() if_else is more strict. It checks that both alternatives are of the same type and otherwise throws an error, while ifelse will promote types as necessary. This may be a benefit in some circumstances, but may otherwise break scripts if you don‚Äôt check for errors or explicitly force type conversion. source: https://stackoverflow.com/questions/50646133/dplyr-if-else-vs-base-r-ifelse For example: ifelse(c(TRUE,TRUE,FALSE),&quot;a&quot;,3) dplyr::if_else(c(TRUE,TRUE,FALSE),&quot;a&quot;,3) It releases an error in dplyr::if_else(c(TRUE, TRUE, FALSE), \"a\", 3) : must be a character vector, not a double vector. An alternative to ifelse defined as condition-vector pairs and more broadly as a general vectorised if is: case_when() It allows you to vectorise multiple if_else() statements Finally, the last tool just mentioned is switch(), here is an example on how to use it: require(stats) centre &lt;- function(x, type) { switch(type, mean = mean(x), median = median(x), trimmed = mean(x, trim = .1)) } set.seed(123) x &lt;- rcauchy(10) require(ggplot2) ggplot(data = data.frame(x), aes(x))+ geom_density()+ geom_vline(xintercept = c(centre(x, &quot;mean&quot;), centre(x, &quot;median&quot;), centre(x, &quot;trimmed&quot;)), size=0.5,linetype=&quot;dashed&quot;, color=c(&quot;darkgreen&quot;,&quot;red&quot;,&quot;blue&quot;))+ xlim(-10,10)+ theme_bw() "],["loops.html", "5.4 Loops", " 5.4 Loops Iteration of a set of values with: for (var in seq) expr while (cond) expr repeat expr break next for (item in vector) perform_action ? for (variable in vector) { } First example for(i in 1:5) { print(1:i) } #&gt; [1] 1 #&gt; [1] 1 2 #&gt; [1] 1 2 3 #&gt; [1] 1 2 3 4 #&gt; [1] 1 2 3 4 5 Second example: terminate a for loop earlier for (i in 1:10) { if (i &lt; 3) next print(i) if (i &gt;= 5) break } #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 More tools while(condition) action: performs action while condition is TRUE. repeat(action): repeats action forever (i.e.¬†until it encounters break). Generally speaking you shouldn‚Äôt need to use for loops for data analysis tasks, as map() and apply() already provide less flexible solutions to most problems. You‚Äôll learn more in Chapter 9. "],["meeting-videos-4.html", "5.5 Meeting Videos", " 5.5 Meeting Videos 5.5.1 Cohort 1 5.5.2 Cohort 2 5.5.3 Cohort 3 5.5.4 Cohort 4 5.5.5 Cohort 5 5.5.6 Cohort 6 Meeting chat log LOG "],["functions.html", "Chapter 6 Functions", " Chapter 6 Functions Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-1.html", "6.1 SLIDE 1", " 6.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-5.html", "6.2 Meeting Videos", " 6.2 Meeting Videos 6.2.1 Cohort 1 6.2.2 Cohort 2 6.2.3 Cohort 3 6.2.4 Cohort 4 6.2.5 Cohort 5 6.2.6 Cohort 6 Meeting chat log LOG "],["environments.html", "Chapter 7 Environments", " Chapter 7 Environments Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-2.html", "7.1 SLIDE 1", " 7.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-6.html", "7.2 Meeting Videos", " 7.2 Meeting Videos 7.2.1 Cohort 1 7.2.2 Cohort 2 7.2.3 Cohort 3 7.2.4 Cohort 4 7.2.5 Cohort 5 7.2.6 Cohort 6 Meeting chat log LOG "],["conditions.html", "Chapter 8 Conditions", " Chapter 8 Conditions Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-3.html", "8.1 SLIDE 1", " 8.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-7.html", "8.2 Meeting Videos", " 8.2 Meeting Videos 8.2.1 Cohort 1 8.2.2 Cohort 2 8.2.3 Cohort 3 8.2.4 Cohort 4 8.2.5 Cohort 5 8.2.6 Cohort 6 Meeting chat log LOG "],["functionals.html", "Chapter 9 Functionals", " Chapter 9 Functionals Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-4.html", "9.1 SLIDE 1", " 9.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-8.html", "9.2 Meeting Videos", " 9.2 Meeting Videos 9.2.1 Cohort 1 9.2.2 Cohort 2 9.2.3 Cohort 3 9.2.4 Cohort 4 9.2.5 Cohort 5 9.2.6 Cohort 6 Meeting chat log LOG "],["function-factories.html", "Chapter 10 Function factories", " Chapter 10 Function factories Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-5.html", "10.1 SLIDE 1", " 10.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-9.html", "10.2 Meeting Videos", " 10.2 Meeting Videos 10.2.1 Cohort 1 10.2.2 Cohort 2 10.2.3 Cohort 3 10.2.4 Cohort 4 10.2.5 Cohort 5 10.2.6 Cohort 6 Meeting chat log LOG "],["function-operators.html", "Chapter 11 Function operators", " Chapter 11 Function operators Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-6.html", "11.1 SLIDE 1", " 11.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-10.html", "11.2 Meeting Videos", " 11.2 Meeting Videos 11.2.1 Cohort 1 11.2.2 Cohort 2 11.2.3 Cohort 3 11.2.4 Cohort 4 11.2.5 Cohort 5 11.2.6 Cohort 6 Meeting chat log LOG "],["base-types.html", "Chapter 12 Base types", " Chapter 12 Base types Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-7.html", "12.1 SLIDE 1", " 12.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-11.html", "12.2 Meeting Videos", " 12.2 Meeting Videos 12.2.1 Cohort 1 12.2.2 Cohort 2 12.2.3 Cohort 3 12.2.4 Cohort 4 12.2.5 Cohort 5 12.2.6 Cohort 6 Meeting chat log LOG "],["s3.html", "Chapter 13 S3", " Chapter 13 S3 Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-8.html", "13.1 SLIDE 1", " 13.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-12.html", "13.2 Meeting Videos", " 13.2 Meeting Videos 13.2.1 Cohort 1 13.2.2 Cohort 2 13.2.3 Cohort 3 13.2.4 Cohort 4 13.2.5 Cohort 5 13.2.6 Cohort 6 Meeting chat log LOG "],["r6.html", "Chapter 14 R6", " Chapter 14 R6 Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-9.html", "14.1 SLIDE 1", " 14.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-13.html", "14.2 Meeting Videos", " 14.2 Meeting Videos 14.2.1 Cohort 1 14.2.2 Cohort 2 14.2.3 Cohort 3 14.2.4 Cohort 4 14.2.5 Cohort 5 14.2.6 Cohort 6 Meeting chat log LOG "],["s4.html", "Chapter 15 S4", " Chapter 15 S4 Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-10.html", "15.1 SLIDE 1", " 15.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-14.html", "15.2 Meeting Videos", " 15.2 Meeting Videos 15.2.1 Cohort 1 15.2.2 Cohort 2 15.2.3 Cohort 3 15.2.4 Cohort 4 15.2.5 Cohort 5 15.2.6 Cohort 6 Meeting chat log LOG "],["trade-offs.html", "Chapter 16 Trade-offs", " Chapter 16 Trade-offs Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-11.html", "16.1 SLIDE 1", " 16.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-15.html", "16.2 Meeting Videos", " 16.2 Meeting Videos 16.2.1 Cohort 1 16.2.2 Cohort 2 16.2.3 Cohort 3 16.2.4 Cohort 4 16.2.5 Cohort 5 16.2.6 Cohort 6 Meeting chat log LOG "],["big-picture.html", "Chapter 17 Big picture", " Chapter 17 Big picture Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-12.html", "17.1 SLIDE 1", " 17.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-16.html", "17.2 Meeting Videos", " 17.2 Meeting Videos 17.2.1 Cohort 1 17.2.2 Cohort 2 17.2.3 Cohort 3 17.2.4 Cohort 4 17.2.5 Cohort 5 17.2.6 Cohort 6 Meeting chat log LOG "],["expressions.html", "Chapter 18 Expressions", " Chapter 18 Expressions Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-13.html", "18.1 SLIDE 1", " 18.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-17.html", "18.2 Meeting Videos", " 18.2 Meeting Videos 18.2.1 Cohort 1 18.2.2 Cohort 2 18.2.3 Cohort 3 18.2.4 Cohort 4 18.2.5 Cohort 5 18.2.6 Cohort 6 Meeting chat log LOG "],["quasiquotation.html", "Chapter 19 Quasiquotation", " Chapter 19 Quasiquotation Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-14.html", "19.1 SLIDE 1", " 19.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-18.html", "19.2 Meeting Videos", " 19.2 Meeting Videos 19.2.1 Cohort 1 19.2.2 Cohort 2 19.2.3 Cohort 3 19.2.4 Cohort 4 19.2.5 Cohort 5 19.2.6 Cohort 6 Meeting chat log LOG "],["evaluation.html", "Chapter 20 Evaluation", " Chapter 20 Evaluation Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-15.html", "20.1 SLIDE 1", " 20.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-19.html", "20.2 Meeting Videos", " 20.2 Meeting Videos 20.2.1 Cohort 1 20.2.2 Cohort 2 20.2.3 Cohort 3 20.2.4 Cohort 4 20.2.5 Cohort 5 20.2.6 Cohort 6 Meeting chat log LOG "],["translating-r-code.html", "Chapter 21 Translating R code", " Chapter 21 Translating R code Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-16.html", "21.1 SLIDE 1", " 21.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-20.html", "21.2 Meeting Videos", " 21.2 Meeting Videos 21.2.1 Cohort 1 21.2.2 Cohort 2 21.2.3 Cohort 3 (no video) 21.2.4 Cohort 4 21.2.5 Cohort 5 21.2.6 Cohort 6 Meeting chat log LOG "],["debugging.html", "Chapter 22 Debugging", " Chapter 22 Debugging Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-17.html", "22.1 SLIDE 1", " 22.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-21.html", "22.2 Meeting Videos", " 22.2 Meeting Videos 22.2.1 Cohort 1 22.2.2 Cohort 2 22.2.3 Cohort 3 22.2.4 Cohort 4 22.2.5 Cohort 5 22.2.6 Cohort 6 Meeting chat log LOG "],["measuring-performance.html", "Chapter 23 Measuring performance", " Chapter 23 Measuring performance Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-18.html", "23.1 SLIDE 1", " 23.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-22.html", "23.2 Meeting Videos", " 23.2 Meeting Videos 23.2.1 Cohort 1 (no video) 23.2.2 Cohort 2 23.2.3 Cohort 3 23.2.4 Cohort 4 23.2.5 Cohort 5 23.2.6 Cohort 6 Meeting chat log LOG "],["improving-performance.html", "Chapter 24 Improving performance", " Chapter 24 Improving performance Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-19.html", "24.1 SLIDE 1", " 24.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-23.html", "24.2 Meeting Videos", " 24.2 Meeting Videos 24.2.1 Cohort 1 (no video) 24.2.2 Cohort 2 24.2.3 Cohort 3 24.2.4 Cohort 4 24.2.5 Cohort 5 24.2.6 Cohort 6 Meeting chat log LOG "],["rewriting-r-code-in-c.html", "Chapter 25 Rewriting R code in C++", " Chapter 25 Rewriting R code in C++ Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-20.html", "25.1 SLIDE 1", " 25.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-24.html", "25.2 Meeting Videos", " 25.2 Meeting Videos 25.2.1 Cohort 1 25.2.2 Cohort 2 25.2.3 Cohort 3 25.2.4 Cohort 4 25.2.5 Cohort 5 25.2.6 Cohort 6 Meeting chat log LOG "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]

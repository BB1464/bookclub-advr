[["index.html", "Advanced R Book Club Welcome", " Advanced R Book Club The R4DS Online Learning Community 2022-09-16 Welcome Welcome to the bookclub! This is a companion for the book Advanced R by Hadley Wickham (Chapman &amp; Hall, copyright 2019, 9780815384571). This companion is available at r4ds.io/advr. This website is being developed by the R4DS Online Learning Community. Follow along, and join the community to participate. This companion follows the R4DS Online Learning Community Code of Conduct. "],["book-club-meetings.html", "Book club meetings", " Book club meetings Each week, a volunteer will present a chapter from the book (or part of a chapter). This is the best way to learn the material. Presentations will usually consist of a review of the material, a discussion, and/or a demonstration of the principles presented in that chapter. More information about how to present is available in the github repo. Presentations will be recorded, and will be available on the R4DS Online Learning Community YouTube Channel. "],["pace.html", "Pace", " Pace We‚Äôll try to cover 1 chapter/week, but‚Ä¶ ‚Ä¶It‚Äôs ok to split chapters when they feel like too much. We will try to meet every week, but will likely take some breaks for holidays, etc. "],["introduction.html", "Chapter 1 Introduction", " Chapter 1 Introduction Learning objectives: For the entire book: Improve programming skills. Develop a deep understanding of the R language fundamentals. Understand what functional programming means. For this chapter (includes the Welcome and Preface): Recognize the differences between the 1st and 2nd edition of this book. Describe the overall structure of the book. Decide whether this book is right for you. Books suggestions: The Structure and Interpretation of Computer Programs (SICP) Concepts, Techniques and Models of Computer Programming The Pragmatic Programmer "],["whats-new.html", "1.1 What‚Äôs new?", " 1.1 What‚Äôs new? ‚ÄúThe first edition used base R functions almost exclusively, this version of the book expands into more advanced functions provided by other pakages.‚Äù ‚ÄúUse of new packages, particularly rlang, which provides a clean interface to low-level data structures and operations.‚Äù Figure 1.1: Twitter: @hadleywickham - 6 June 2019 "],["overview-of-the-book-structure.html", "1.2 Overview of the book structure", " 1.2 Overview of the book structure The book is composed of five sections. A step by step path towards mastering R techniques. The Foundations is the part in which the R components will be examined. It will help understanding how to use all the basics tools to deal with functions and structures. The Functional programming goes a little more in dept into programming with R, making functions of functions. Describing function factories and operators. The Object-oriented programming - OOP is a five chapter section, all about object oriented systems among S3, R6 and S4. The Metaprogramming section introduces you through the programming layers. Finally, the Techniques section is dedicated to finding and fixing bugs and improving performances. 1.2.1 Foundations Six chapters to learn the foundational components of R. The last chapter ‚Äúconditions‚Äù describe errors, warnings, and messages. 1.2.2 Functional programming This part of the book is dedicated to functions: function factories and operators. 1.2.3 Object-oriented programming OOP is the most dense part of the book, as it mentions about systems which interact with R. 1.2.4 Metaprogramming This is the part of the book where things are blended to the Big Picture. R is a versatile functional language that can be managed and assembled. 1.2.5 Techniques Finally, this is the last section of the book, where debugging is used to measure and improve performance. And how to improve performance by rewriting key functions in C++. "],["resources.html", "1.3 Resources", " 1.3 Resources first edition advanced-r-solutions "],["meeting-videos.html", "1.4 Meeting Videos", " 1.4 Meeting Videos 1.4.1 Cohort 1 (no video recorded) 1.4.2 Cohort 2 1.4.3 Cohort 3 1.4.4 Cohort 4 1.4.5 Cohort 5 1.4.6 Cohort 6 Meeting chat log 00:14:40 SriRam: From Toronto, Civil Engineer. I use R for infrastructure planning/ GIS. Here coz of the ping üòÑ , was not ready with a good computer with mic/audio ! 00:15:20 SriRam: I was with Ryan, Federica on other courses 00:23:21 SriRam: I think the only caution is about Copyright issues 00:31:32 Ryan Metcalf: Citation, giving credit back to source. Great comment SriRam. 00:34:33 SriRam: one = one, in my opinion 00:41:53 Ryan Metcalf: https://docs.google.com/spreadsheets/d/1_WFY82UxAdvP4GUdZ2luh15quwdO1n0Km3Q0tfYuqvc/edit#gid=0 00:48:35 Arthur Shaw: The README has a nice step-by-step process at the bottom: https://github.com/r4ds/bookclub-advr#how-to-present. I&#39;ve not done this myself yet, but it looks fairly straightforward. 00:54:13 lucus w: Thanks Ryan. Probably {usethis} will be easier. It looks straight forward 01:00:02 Moria W.: Thank you for sharing that. This has been good! 01:00:08 Vaibhav Janve: Thank you 01:00:44 Federica Gazzelloni: hi SriRam we are going.. "],["names-and-values.html", "Chapter 2 Names and values", " Chapter 2 Names and values Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1.html", "2.1 SLIDE 1", " 2.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-1.html", "2.2 Meeting Videos", " 2.2 Meeting Videos 2.2.1 Cohort 1 (no video recorded) 2.2.2 Cohort 2 2.2.3 Cohort 3 2.2.4 Cohort 4 2.2.5 Cohort 5 2.2.6 Cohort 6 Meeting chat log 00:16:57 Federica Gazzelloni: cohort 2 video: https://www.youtube.com/watch?v=pCiNj2JRK50 00:18:39 Federica Gazzelloni: cohort 2 presentation: https://r4ds.github.io/bookclub-Advanced_R/Presentations/Week02/Cohort2_America/Chapter2Slides.html#1 00:40:24 Arthur Shaw: Just the opposite, Ryan. Very clear presentation! 00:51:54 Trevin: parquet? 00:53:00 Arthur Shaw: We may all be right. {arrow} looks to deal with feather and parquet files: https://arrow.apache.org/docs/r/ 01:00:04 Arthur Shaw: Some questions for future meetings. (1) I find Ryan&#39;s use of slides hugely effective in conveying information. Would it be OK if future sessions (optionally) used slides? If so, should/could we commit slides to some folder on the repo? (2) I think reusing the images from Hadley&#39;s books really helps understanding and discussion. Is that OK to do? Here I&#39;m thinking about copyright concerns. (If possible, I would rather not redraw variants of Hadley&#39;s images.) 01:01:35 Federica Gazzelloni: It&#39;s all ok, you can use past presentation, you don&#39;t need to push them to the repo, you can use the images from the book 01:07:19 Federica Gazzelloni: Can I use: gc(reset = TRUE) safely? "],["vectors.html", "Chapter 3 Vectors", " Chapter 3 Vectors Learning objectives: Learn about different types of vectors Learn how these types relate to one another "],["types-of-vectors.html", "3.1 Types of vectors", " 3.1 Types of vectors The family tree of vectors: Credit: Advanced R by Hadley Wickham Atomic. Elements all the same type. List. Elements are different Types. NULL Null elements. Length zero. "],["atomic-vectors.html", "3.2 Atomic vectors", " 3.2 Atomic vectors 3.2.1 Types The vector family tree revisited. Meet the children of atomic vectors Credit: Advanced R by Hadley Wickham 3.2.2 Length one ‚ÄúScalars‚Äù that consist of a single value. # Logicals lgl1 &lt;- TRUE lgl2 &lt;- T # Doubles # integer, decimal, scientific, or hexidecimal format dbl1 &lt;- 1 dbl2 &lt;- 1.234 dbl3 &lt;- 1.234e0 dbl4 &lt;- 0xcafe # Integers # Note: L denotes an integer int1 &lt;- 1L int2 &lt;- 1.234L int3 &lt;- 1.234e0L int4 &lt;- 0xcafeL # Strings str1 &lt;- &quot;hello&quot; # double quotes str2 &lt;- &#39;hello&#39; # single quotes str3 &lt;- &quot;ŸÖÿ±ÿ≠ÿ®Ÿãÿß&quot; # Unicode str4 &lt;- &quot;\\U0001f605&quot; # sweaty_smile 3.2.3 Longer Several ways to make longer: 1. With single values lgl_vec &lt;- c(TRUE, FALSE) 2. With other vectors c(c(1, 2), c(3, 4)) #&gt; [1] 1 2 3 4 See also {rlang} has vector constructor functions too: rlang::lgl(...) rlang::int(...) rlang::dbl(...) rlang::chr(...) They look to do both more and less than c(). More: Enforce type Splice lists More types: rlang::bytes(), rlang::cpl(...) Less: Stricter rules on names Note: currently has questioning lifecycle badge, since these constructors may get moved to vctrs 3.2.4 Missing values Contagion For most computations, an operation over values that includes a missing value yields a missing value (unless you‚Äôre careful) # contagion 5*NA #&gt; [1] NA sum(c(1, 2, NA, 3)) #&gt; [1] NA # innoculate sum(c(1, 2, NA, 3), na.rm = TRUE) #&gt; [1] 6 Types Each type has its own NA type Logical: NA Integer: NA_integer Double: NA_double Character: NA_character This may not matter in many contexts. But this does matter for operations where types matter like dplyr::if_else(). 3.2.5 Testing What type of vector is.*() it? Test data type: Logical: is.logical() Integer: is.integer() Double: is.double() Character: is.character() What type of object is it? Don‚Äôt test objects with these tools: is.vector() is.atomic() is.numeric() Instead, maybe, use {rlang} rlang::is_vector rlang::is_atomic # vector rlang::is_vector(c(1, 2)) #&gt; [1] TRUE rlang::is_vector(list(1, 2)) #&gt; [1] TRUE # atomic rlang::is_atomic(c(1, 2)) #&gt; [1] TRUE rlang::is_atomic(list(1, &quot;a&quot;)) #&gt; [1] FALSE See more here 3.2.6 Coercion R follows rules for coercion: character ‚Üí double ‚Üí integer ‚Üí logical R can coerce either automatically or explicitly Automatic Two contexts for automatic coercion: Combination Mathematical Combination: str(c(TRUE, &quot;TRUE&quot;)) #&gt; chr [1:2] &quot;TRUE&quot; &quot;TRUE&quot; Mathematical operations # imagine a logical vector about whether an attribute is present has_attribute &lt;- c(TRUE, FALSE, TRUE, TRUE) # number with attribute sum(has_attribute) #&gt; [1] 3 Explicit Use as.*() Logical: as.logical() Integer: as.integer() Double: as.double() Character: as.character() But note that coercions may fail in one of two ways, or both: With warning/error NAs as.integer(c(1, 2, &quot;three&quot;)) #&gt; Warning: NAs introduced by coercion #&gt; [1] 1 2 NA "],["attributes.html", "3.3 Attributes", " 3.3 Attributes What How Why 3.3.1 What Two perspectives: Name-value pairs Metadata Name-value pairs Formally, attributes have a name and a value. Metadata Not data itself But data about the data 3.3.2 How Two operations: Get Set Two cases: Single attribute Multiple attributes Single attribute Use attr() # some object a &lt;- c(1, 2, 3) # set attribute attr(x = a, which = &quot;some_attribute_name&quot;) &lt;- &quot;some attribute&quot; # get attribute attr(x = a, which = &quot;some_attribute_name&quot;) #&gt; [1] &quot;some attribute&quot; Multiple attributes To set multiple attributes, use structure() To get multiple attributes, use attributes() b &lt;- c(4, 5, 6) # set b &lt;- structure( .Data = b, attrib1 = &quot;one&quot;, attrib2 = &quot;two&quot; ) # get str(attributes(b)) #&gt; List of 2 #&gt; $ attrib1: chr &quot;one&quot; #&gt; $ attrib2: chr &quot;two&quot; 3.3.3 Why Two common use cases: Names Dimensions Names Three Four ways to name: # 1. At creation one &lt;- c(one = 1, two = 2, three = 3) # 2. By assigning a character vector of names two &lt;- c(1, 2, 3) names(two) &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;) # 3. By setting names--with base R three &lt;- c(1, 2, 3) stats::setNames( object = three, nm = c(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;) ) #&gt; One Two Three #&gt; 1 2 3 # 4. By setting names--with {rlang} rlang::set_names( x = three, nm = c(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;) ) #&gt; One Two Three #&gt; 1 2 3 Thematically but not directly related: labelled class vectors with haven::labelled() Dimensions Important for arrays and matrices. # length 6 vector spread across 2 rows of 3 columns matrix(1:6, nrow = 2, ncol = 3) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 "],["s3-atomic-vectors.html", "3.4 S3 atomic vectors", " 3.4 S3 atomic vectors The vector family tree revisited. Meet the children of typed atomic vectors Credit: Advanced R by Hadley Wickham This list could (more easily) be expanded to new vector types with {vctrs}. See rstudio::conf(2019) talk on the package around 18:27. See also rstudio::conf(2020) talk on new vector types for dealing with non-decimal currencies. What makes S3 atomic vectors different than their parents? Two things: Class Attributes (typically) 3.4.1 Factors Factors are integer vectors with: Class: ‚Äúfactor‚Äù Attributes: ‚Äúlevels‚Äù, or the set of allowed values # Build a factor a_factor &lt;- factor( # values x = c(1, 2, 3), # exhaustive list of values levels = c(1, 2, 3, 4) ) # Inspect a_factor #&gt; [1] 1 2 3 #&gt; Levels: 1 2 3 4 # Dissect # - type typeof(a_factor) #&gt; [1] &quot;integer&quot; # - attributes attributes(a_factor) #&gt; $levels #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; #&gt; #&gt; $class #&gt; [1] &quot;factor&quot; Factors can be ordered. This can be useful for models or visaulations where order matters. # Build ordered_factor &lt;- ordered( # values x = c(1, 2, 3), # levels in ascending order levels = c(4, 3, 2, 1) ) # Inspect ordered_factor #&gt; [1] 1 2 3 #&gt; Levels: 4 &lt; 3 &lt; 2 &lt; 1 3.4.2 Dates Dates are: Double vectors With class ‚ÄúDate‚Äù The double component represents the number of days since since 1970-01-01 notes_date &lt;- Sys.Date() # type typeof(notes_date) #&gt; [1] &quot;double&quot; # class attributes(notes_date) #&gt; $class #&gt; [1] &quot;Date&quot; 3.4.3 Date-times There are 2 Date-time representations in base R: POSIXct, where ‚Äúct‚Äù denotes calendar time POSIXlt, where ‚Äúlt‚Äù designates local time. Let‚Äôs focus on POSIXct because: Simplest Built on an atomic vector Most apt to be in a data frame Let‚Äôs now build and deconstruct a Date-time # Build note_date_time &lt;- as.POSIXct( # time x = Sys.time(), # time zone, used only for formatting tz = &quot;EDT&quot; ) # Inspect note_date_time #&gt; [1] &quot;2022-09-16 15:28:31 UTC&quot; # Dissect # - type typeof(note_date_time) #&gt; [1] &quot;double&quot; # - attributes attributes(note_date_time) #&gt; $class #&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot; 3.4.4 Durations Durations are: Double vectors Class: ‚Äúdifftime‚Äù Attributes: ‚Äúunits‚Äù, or the unit of duration (e.g., weeks, hours, minutes, seconds, etc.) # Construct one_minute &lt;- as.difftime(1, units = &quot;mins&quot;) # Inspect one_minute #&gt; Time difference of 1 mins # Dissect # - type typeof(one_minute) #&gt; [1] &quot;double&quot; # - attributes attributes(one_minute) #&gt; $class #&gt; [1] &quot;difftime&quot; #&gt; #&gt; $units #&gt; [1] &quot;mins&quot; See also: lubridate::make_difftime() clock::date_time_build() "],["lists.html", "3.5 Lists", " 3.5 Lists Sometimes called a generic vector, a list can be composed of elements of different types. 3.5.1 Constructing Simple lists: # Construct simple_list &lt;- list( # logicals c(TRUE, FALSE), # integers 1:20, # doubles c(1.2, 2.3, 3.4), # characters c(&quot;primo&quot;, &quot;secundo&quot;, &quot;tercio&quot;) ) # Inspect # - type typeof(simple_list) #&gt; [1] &quot;list&quot; # - structure str(simple_list) #&gt; List of 4 #&gt; $ : logi [1:2] TRUE FALSE #&gt; $ : int [1:20] 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ : num [1:3] 1.2 2.3 3.4 #&gt; $ : chr [1:3] &quot;primo&quot; &quot;secundo&quot; &quot;tercio&quot; Nested lists: nested_list &lt;- list( # first level list( # second level list( # third level list(1) ) ) ) str(nested_list) #&gt; List of 1 #&gt; $ :List of 1 #&gt; ..$ :List of 1 #&gt; .. ..$ :List of 1 #&gt; .. .. ..$ : num 1 Like JSON. Combined lists # with list() list_comb1 &lt;- list(list(1, 2), list(3, 4)) # with c() list_comb2 &lt;- c(list(1, 2), list(3, 4)) # compare structure str(list_comb1) #&gt; List of 2 #&gt; $ :List of 2 #&gt; ..$ : num 1 #&gt; ..$ : num 2 #&gt; $ :List of 2 #&gt; ..$ : num 3 #&gt; ..$ : num 4 str(list_comb2) #&gt; List of 4 #&gt; $ : num 1 #&gt; $ : num 2 #&gt; $ : num 3 #&gt; $ : num 4 3.5.2 Testing Check that is a list: is.list() `rlang::is_list()`` The two do the same, except that the latter can check for the number of elements # is list base::is.list(list_comb2) #&gt; [1] TRUE rlang::is_list(list_comb2) #&gt; [1] TRUE # is list of 4 elements rlang::is_list(x = list_comb2, n = 4) #&gt; [1] TRUE # is a vector (of a special type) # remember the family tree? rlang::is_vector(list_comb2) #&gt; [1] TRUE 3.5.3 Coercion "],["data-frames-and-tibbles.html", "3.6 Data frames and tibbles", " 3.6 Data frames and tibbles The vector family tree revisited. Meet the children of lists Credit: Advanced R by Hadley Wickham 3.6.1 Data frame A data frame is a: Named list of vectors (i.e., column names) Class: ‚Äúdata frame‚Äù Attributes: (column) names `row.names`` # Construct df &lt;- data.frame( # named atomic vector col1 = c(1, 2, 3), # another named atomic vector col2 = c(&quot;un&quot;, &quot;deux&quot;, &quot;trois&quot;), # not necessary after R 4.1 (?) stringsAsFactors = FALSE ) # Inspect df #&gt; col1 col2 #&gt; 1 1 un #&gt; 2 2 deux #&gt; 3 3 trois # Deconstruct # - type typeof(df) #&gt; [1] &quot;list&quot; # - attributes attributes(df) #&gt; $names #&gt; [1] &quot;col1&quot; &quot;col2&quot; #&gt; #&gt; $class #&gt; [1] &quot;data.frame&quot; #&gt; #&gt; $row.names #&gt; [1] 1 2 3 Unlike other lists, the length of each vector must be the same (i.e.¬†as many vector elements as rows in the data frame). 3.6.2 Tibble As compared to data frames, tibbles are data frames that are: Lazy Surly 3.6.2.1 Lazy Tibbles do not: Coerce strings Transform non-syntactic names Recycle vectors of length greater than 1 Coerce strings chr_col &lt;- c(&quot;don&#39;t&quot;, &quot;factor&quot;, &quot;me&quot;, &quot;bro&quot;) # data frame df &lt;- data.frame( a = chr_col, # in R 4.1 and earlier, this was the default stringsAsFactors = TRUE ) # tibble tbl &lt;- tibble::tibble( a = chr_col ) # contrast the structure str(df$a) #&gt; Factor w/ 4 levels &quot;bro&quot;,&quot;don&#39;t&quot;,..: 2 3 4 1 str(tbl$a) #&gt; chr [1:4] &quot;don&#39;t&quot; &quot;factor&quot; &quot;me&quot; &quot;bro&quot; Transform non-syntactic names # data frame df &lt;- data.frame( `1` = c(1, 2, 3) ) # tibble tbl &lt;- tibble::tibble( `1` = c(1, 2, 3) ) # contrast the names names(df) #&gt; [1] &quot;X1&quot; names(tbl) #&gt; [1] &quot;1&quot; Recycle vectors of length greater than 1 # data frame df &lt;- data.frame( col1 = c(1, 2, 3, 4), col2 = c(1, 2) ) # tibble tbl &lt;- tibble::tibble( col1 = c(1, 2, 3, 4), col2 = c(1, 2) ) #&gt; Error: #&gt; ! Tibble columns must have compatible sizes. #&gt; ‚Ä¢ Size 4: Existing data. #&gt; ‚Ä¢ Size 2: Column `col2`. #&gt; ‚Ñπ Only values of size one are recycled. 3.6.2.2 Surly Tibbles do only what they‚Äôre asked and complain if what they‚Äôre asked doesn‚Äôt make sense: Subsetting always yields a tibble Complains if cannot find column Subsetting always yields a tibble # data frame df &lt;- data.frame( col1 = c(1, 2, 3, 4) ) # tibble tbl &lt;- tibble::tibble( col1 = c(1, 2, 3, 4) ) # contrast df_col &lt;- df[, &quot;col1&quot;] str(df_col) #&gt; num [1:4] 1 2 3 4 tbl_col &lt;- tbl[, &quot;col1&quot;] str(tbl_col) #&gt; tibble [4 √ó 1] (S3: tbl_df/tbl/data.frame) #&gt; $ col1: num [1:4] 1 2 3 4 # to select a vector, do one of these instead tbl_col_1 &lt;- tbl[[&quot;col1&quot;]] str(tbl_col_1) #&gt; num [1:4] 1 2 3 4 tbl_col_2 &lt;- dplyr::pull(tbl, col1) str(tbl_col_2) #&gt; num [1:4] 1 2 3 4 Complains if cannot find column names(df) #&gt; [1] &quot;col1&quot; df$col #&gt; [1] 1 2 3 4 names(tbl) #&gt; [1] &quot;col1&quot; tbl$col #&gt; Warning: Unknown or uninitialised column: `col`. #&gt; NULL 3.6.3 Testing Whether data frame: is.data.frame(). Note: both data frame and tibble are data frames. Whether tibble: tibble::is_tibble. Note: only tibbles are tibbles. Vanilla data frames are not. 3.6.4 Coercion To data frame: as.data.frame() To tibble: tibble::as_tibble() "],["null.html", "3.7 NULL", " 3.7 NULL Special type of object that: Length 0 Cannot have attributes typeof(NULL) #&gt; [1] &quot;NULL&quot; #&gt; [1] &quot;NULL&quot; length(NULL) #&gt; [1] 0 #&gt; [1] 0 x &lt;- NULL attr(x, &quot;y&quot;) &lt;- 1 #&gt; Error in attr(x, &quot;y&quot;) &lt;- 1: attempt to set an attribute on NULL "],["meeting-videos-2.html", "3.8 Meeting Videos", " 3.8 Meeting Videos 3.8.1 Cohort 1 3.8.2 Cohort 2 3.8.3 Cohort 3 3.8.4 Cohort 4 3.8.5 Cohort 5 3.8.6 Cohort 6 Meeting chat log 00:10:18 Oluwafemi Oyedele: Hi, good evening 00:23:31 Federica Gazzelloni: Hi Kiante! 00:24:21 Federica Gazzelloni: Thanks Arthur 00:25:46 Trevin: Welcome Matt! 00:26:02 Matt Dupree: hello! thank you! 00:30:34 Federica Gazzelloni: Hello Matt! 00:30:46 Matt Dupree: hello! 00:38:24 Ryan Metcalf: `rlang::cpl()` = ‚Äúcomplex‚Äù. For example `0+1i` 00:55:37 Trevin: &gt; two &lt;- c(1,2,3) &gt; names(two) &lt;- c(&quot;one&quot;, &quot;two&quot;) &gt; two one two &lt;NA&gt; 1 2 3 00:57:25 Ryan Metcalf: Excellent Trevin. You beat me to the output! Assuming we didn&#39;t supply the string, `NA` is entered instead. 01:08:50 Ryan Metcalf: Without further research, this is the &quot;Unix Epoch‚Äù. However, varying operating systems use different Epochs. "],["subsetting.html", "Chapter 4 Subsetting", " Chapter 4 Subsetting Learning objectives: Learn about the 6 ways to subset atomic vectors Learn about the 3 subsetting operators: [[, [, and $ Learn how subsetting works with different vector types "],["selecting-multiple-elements.html", "4.1 Selecting multiple elements", " 4.1 Selecting multiple elements 4.1.1 Atomic Vectors 6 ways to subset atomic vectors Let‚Äôs take a look with an example vector. x &lt;- c(3.1, 2.2, 1.3, 4.4) Positive integers # return elements at specified positions x[c(4, 1)] #&gt; [1] 4.4 3.1 # duplicate indices return duplicate values x[c(2, 2)] #&gt; [1] 2.2 2.2 # real numbers truncate to integers x[c(3.2, 3.8)] #&gt; [1] 1.3 1.3 Negative integers ### excludes elements at specified positions # x[-c(1, 3)] # same as x[c(-1, -3)] ### mixing positive and negative is a no-no # x[c(-1, 3)] Logical Vectors x[c(TRUE, TRUE, FALSE, TRUE)] #&gt; [1] 3.1 2.2 4.4 x[x &lt; 3] #&gt; [1] 2.2 1.3 Recyling rules apply when subsetting this way: x[y] Easy to understand if x or y is 1, best to avoid other lengths # missing value in index will also return NA in output x[c(NA, TRUE)] #&gt; [1] NA 2.2 NA 4.4 Nothing # returns the original vector x[] #&gt; [1] 3.1 2.2 1.3 4.4 Zero # returns a zero-length vector x[0] #&gt; numeric(0) Character vectors # if name, you can use to return matched elements (y &lt;- setNames(x, letters[1:4])) #&gt; a b c d #&gt; 3.1 2.2 1.3 4.4 y[c(&quot;d&quot;, &quot;b&quot;, &quot;a&quot;)] #&gt; d b a #&gt; 4.4 2.2 3.1 4.1.2 Lists Subsetting works the same way [ always returns a list, [[ and $ let you pull elements out of a list 4.1.3 Matrices and arrays You can subset higher dimensional structures in three ways: - with multiple vectors - with a single vector - with a matrix a &lt;- matrix(1:9, nrow = 3) colnames(a) &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) a[1:2, ] #&gt; A B C #&gt; [1,] 1 4 7 #&gt; [2,] 2 5 8 a[c(TRUE, FALSE, TRUE), c(&quot;B&quot;, &quot;A&quot;)] #&gt; B A #&gt; [1,] 4 1 #&gt; [2,] 6 3 a[0, -2] #&gt; A C a[1, ] #&gt; A B C #&gt; 1 4 7 a[1, 1] #&gt; A #&gt; 1 Credit: Advanced R by Hadley Wickham Matrices and arrays are just special vectors; can subset with a single vector (arrays in R stored column wise) vals &lt;- outer(1:5, 1:5, FUN = &quot;paste&quot;, sep = &quot;,&quot;) vals #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] &quot;1,1&quot; &quot;1,2&quot; &quot;1,3&quot; &quot;1,4&quot; &quot;1,5&quot; #&gt; [2,] &quot;2,1&quot; &quot;2,2&quot; &quot;2,3&quot; &quot;2,4&quot; &quot;2,5&quot; #&gt; [3,] &quot;3,1&quot; &quot;3,2&quot; &quot;3,3&quot; &quot;3,4&quot; &quot;3,5&quot; #&gt; [4,] &quot;4,1&quot; &quot;4,2&quot; &quot;4,3&quot; &quot;4,4&quot; &quot;4,5&quot; #&gt; [5,] &quot;5,1&quot; &quot;5,2&quot; &quot;5,3&quot; &quot;5,4&quot; &quot;5,5&quot; vals[c(3, 15)] #&gt; [1] &quot;3,1&quot; &quot;5,3&quot; 4.1.4 Data frames and tibbles Data frames act like lists and matrices - single index -&gt; list - two indices -&gt; matrix library(palmerpenguins) # single index penguins[1:2] #&gt; # A tibble: 344 √ó 2 #&gt; species island #&gt; &lt;fct&gt; &lt;fct&gt; #&gt; 1 Adelie Torgersen #&gt; 2 Adelie Torgersen #&gt; 3 Adelie Torgersen #&gt; 4 Adelie Torgersen #&gt; 5 Adelie Torgersen #&gt; 6 Adelie Torgersen #&gt; 7 Adelie Torgersen #&gt; 8 Adelie Torgersen #&gt; 9 Adelie Torgersen #&gt; 10 Adelie Torgersen #&gt; # ‚Ä¶ with 334 more rows penguins[c(&quot;species&quot;,&quot;island&quot;)] #&gt; # A tibble: 344 √ó 2 #&gt; species island #&gt; &lt;fct&gt; &lt;fct&gt; #&gt; 1 Adelie Torgersen #&gt; 2 Adelie Torgersen #&gt; 3 Adelie Torgersen #&gt; 4 Adelie Torgersen #&gt; 5 Adelie Torgersen #&gt; 6 Adelie Torgersen #&gt; 7 Adelie Torgersen #&gt; 8 Adelie Torgersen #&gt; 9 Adelie Torgersen #&gt; 10 Adelie Torgersen #&gt; # ‚Ä¶ with 334 more rows # two indices penguins[1:2, ] #&gt; # A tibble: 2 √ó 8 #&gt; species island bill_length_mm bill_depth_mm flipper_l‚Ä¶¬π body_‚Ä¶¬≤ sex year #&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 Adelie Torgersen 39.1 18.7 181 3750 male 2007 #&gt; 2 Adelie Torgersen 39.5 17.4 186 3800 fema‚Ä¶ 2007 #&gt; # ‚Ä¶ with abbreviated variable names ¬π‚Äãflipper_length_mm, ¬≤‚Äãbody_mass_g Subsetting a tibble with [ always returns a tibble 4.1.5 Preserving dimensionality Data frames and tibbles behave differently tibble will default to preserve dimensionality, data frames do not this can lead to unexpected behavior and code breaking in the future Can use drop = FALSE when using a data frame or can use tibbles "],["selecting-a-single-element.html", "4.2 Selecting a single element", " 4.2 Selecting a single element [[ and $ are used to extract single elements 4.2.1 [[]] x &lt;- list(1:3, &quot;a&quot;, 4:6) Credit: Advanced R by Hadley Wickham 4.2.2 $ x$y is equivalent to x[[\"y\"]] the $ operator doens‚Äôt work with stored vals var &lt;- &quot;cyl&quot; # Doesn&#39;t work - mtcars$var translated to mtcars[[&quot;var&quot;]] mtcars$var #&gt; NULL # Instead use [[ mtcars[[var]] #&gt; [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4 $ allows partial matching, [[]] does not x &lt;- list(abc = 1) x$a #&gt; [1] 1 x[[&quot;a&quot;]] #&gt; NULL Hadley advises to change Global settings: options(warnPartialMatchDollar = TRUE) x$a #&gt; Warning in x$a: partial match of &#39;a&#39; to &#39;abc&#39; #&gt; [1] 1 tibbles don‚Äôt have this behavior penguins$s #&gt; Warning: Unknown or uninitialised column: `s`. #&gt; NULL 4.2.3 missing and out of bound indices Due to the inconsistency of how R handles such indices, purrr::pluck() and purrr::chuck() are recommended x &lt;- list( a = list(1, 2, 3), b = list(3, 4, 5) ) purrr::pluck(x, &quot;a&quot;, 1) # [1] 1 purrr::pluck(x, &quot;c&quot;, 1) # NULL purrr::pluck(x, &quot;c&quot;, 1, .default = NA) # [1] NA 4.2.4 @ and slot() @ is $ for S4 objects (to be revisited in Chapter 15) slot() is [[ ]] for S4 objects "],["subsetting-and-assignment.html", "4.3 Subsetting and Assignment", " 4.3 Subsetting and Assignment Subsetting can be combined with assignment to edit values x &lt;- c(&quot;Tigers&quot;, &quot;Royals&quot;, &quot;White Sox&quot;, &quot;Twins&quot;, &quot;Indians&quot;) x[5] &lt;- &quot;Guardians&quot; x #&gt; [1] &quot;Tigers&quot; &quot;Royals&quot; &quot;White Sox&quot; &quot;Twins&quot; &quot;Guardians&quot; length of the subset and assignment vector should be the same to avoid recycling You can use NULL to remove a component x &lt;- list(a = 1, b = 2) x[[&quot;b&quot;]] &lt;- NULL str(x) #&gt; List of 1 #&gt; $ a: num 1 Subsetting with nothing can preserve structure of original object # mtcars[] &lt;- lapply(mtcars, as.integer) # is.data.frame(mtcars) # [1] TRUE # mtcars &lt;- lapply(mtcars, as.integer) #&gt; is.data.frame(mtcars) # [1] FALSE "],["applications.html", "4.4 Applications", " 4.4 Applications Applications copied from cohort 2 slide 4.4.1 Lookup tables (character subsetting) x &lt;- c(&quot;m&quot;, &quot;f&quot;, &quot;u&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;, &quot;m&quot;) lookup &lt;- c(m = &quot;Male&quot;, f = &quot;Female&quot;, u = NA) lookup[x] # m f u f f m m # &quot;Male&quot; &quot;Female&quot; NA &quot;Female&quot; &quot;Female&quot; &quot;Male&quot; &quot;Male&quot; 4.4.2 Matching and merging by hand (integer subsetting) The match() function allows merging a vector with a table grades &lt;- c(&quot;D&quot;, &quot;A&quot;, &quot;C&quot;, &quot;B&quot;, &quot;F&quot;) info &lt;- data.frame( grade = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;F&quot;), desc = c(&quot;Excellent&quot;, &quot;Very Good&quot;, &quot;Average&quot;, &quot;Fair&quot;, &quot;Poor&quot;), fail = c(F, F, F, F, T) ) id &lt;- match(grades, info$grade) id # [1] 3 2 2 1 3 info[id, ] # grade desc fail # 4 D Fair FALSE # 1 A Excellent FALSE # 3 C Average FALSE # 2 B Very Good FALSE # 5 F Poor TRUE 4.4.3 Random samples and bootstrapping (integer subsetting) # mtcars[sample(nrow(mtcars), 3), ] # use replace = TRUE to replace # mpg cyl disp hp drat wt qsec vs am gear carb # Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 # Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 # Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 4.4.4 Ordering (integer subsetting) # mtcars[order(mtcars$mpg), ] # mpg cyl disp hp drat wt qsec vs am gear carb # Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 # Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 # Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 # Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 # Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 # Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 # ... 4.4.5 Expanding aggregated counts (integer subsetting) We can expand a count column by using rep() df &lt;- tibble::tibble(x = c(&quot;Amy&quot;, &quot;Julie&quot;, &quot;Brian&quot;), n = c(2, 1, 3)) df[rep(1:nrow(df), df$n), ] # A tibble: 6 x 2 # x n # &lt;chr&gt; &lt;dbl&gt; # 1 Amy 2 # 2 Amy 2 # 3 Julie 1 # 4 Brian 3 # 5 Brian 3 # 6 Brian 3 4.4.6 Removing columns from data frames (character) We can remove a column by subsetting, which does not change the object df[, 1] # A tibble: 3 x 1 # x # &lt;chr&gt; # 1 Amy # 2 Julie # 3 Brian We can also delete the column using NULL df$n &lt;- NULL df # A tibble: 3 x 1 # x # &lt;chr&gt; # 1 Amy # 2 Julie # 3 Brian 4.4.7 Selecting rows based on a condition (logical subsetting) # mtcars[mtcars$gear == 5, ] # mpg cyl disp hp drat wt qsec vs am gear carb # Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.7 0 1 5 2 # Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 # Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.5 0 1 5 4 # Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.5 0 1 5 6 # Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.6 0 1 5 8 4.4.8 Boolean algebra versus sets (logical and integer) which() gives the indices of a Boolean vector (x1 &lt;- 1:10 %% 2 == 0) # 1-10 divisible by 2 # [1] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE (x2 &lt;- which(x1)) # [1] 2 4 6 8 10 (y1 &lt;- 1:10 %% 5 == 0) # 1-10 divisible by 5 # [1] FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE TRUE (y2 &lt;- which(y1)) # [1] 5 10 x1 &amp; y1 # [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE "],["meeting-videos-3.html", "4.5 Meeting Videos", " 4.5 Meeting Videos 4.5.1 Cohort 1 4.5.2 Cohort 2 4.5.3 Cohort 3 4.5.4 Cohort 4 4.5.5 Cohort 5 4.5.6 Cohort 6 Meeting chat log 00:36:02 Arthur Shaw: TIL that the subset operator has parameters. Thanks, Trevin! 00:38:55 Vaibhav Janve: its interesting that carriage &quot;a&quot; has two set of wheels instread of 4. I wonder that choice is because its atomic. 00:40:44 Arthur Shaw: @Vaibhav, because the load is lighter, the carriage needs fewer axles? ;) I agree: it&#39;s a confusing graphical choice. 00:41:11 Vaibhav Janve: lol 01:05:53 Vaibhav Janve: Thank you Trevin! "],["control-flow.html", "Chapter 5 Control flow", " Chapter 5 Control flow Learning objectives: What are the tools for controlling a flow What is the difference between choices (if, switch) and loops (for, while) How to use conditional tools in data analysis "],["introduction-1.html", "5.1 Introduction", " 5.1 Introduction In this chapter we will see how to use conditions for making data analysis. There are two main group of conditional tools: choices and loops. These are both very useful for making iterating data analysis such as multiple substitutions matching predefined inputs or performing more or less flexible indexing. "],["choices-and-loops.html", "5.2 Choices and Loops", " 5.2 Choices and Loops Iterators of objects pointing to an element inside the container Use if to specify a block of code to be executed, if a specified condition is true. Use else to specify a block of code to be executed, if the same condition is false. Use else if to specify a new condition to test, if the first condition is false. "],["choises.html", "5.3 Choises", " 5.3 Choises if() and ifelse() if (condition) true_action if (condition) true_action else false_action if (test_expression) { yes } if (test_expression) { yes } else if (other test_expression) { no } else { other } --- ifelse(test, yes, no) Note: What is the difference? dplyr::if_else() and base R ifelse() if_else is more strict. It checks that both alternatives are of the same type and otherwise throws an error, while ifelse will promote types as necessary. This may be a benefit in some circumstances, but may otherwise break scripts if you don‚Äôt check for errors or explicitly force type conversion. source: https://stackoverflow.com/questions/50646133/dplyr-if-else-vs-base-r-ifelse For example: ifelse(c(TRUE,TRUE,FALSE),&quot;a&quot;,3) dplyr::if_else(c(TRUE,TRUE,FALSE),&quot;a&quot;,3) It releases an error in dplyr::if_else(c(TRUE, TRUE, FALSE), \"a\", 3) : must be a character vector, not a double vector. An alternative to ifelse defined as condition-vector pairs and more broadly as a general vectorised if is: case_when() It allows you to vectorise multiple if_else() statements Finally, the last tool just mentioned is switch(), here is an example on how to use it: require(stats) centre &lt;- function(x, type) { switch(type, mean = mean(x), median = median(x), trimmed = mean(x, trim = .1)) } set.seed(123) x &lt;- rcauchy(10) require(ggplot2) ggplot(data = data.frame(x), aes(x))+ geom_density()+ geom_vline(xintercept = c(centre(x, &quot;mean&quot;), centre(x, &quot;median&quot;), centre(x, &quot;trimmed&quot;)), size=0.5,linetype=&quot;dashed&quot;, color=c(&quot;darkgreen&quot;,&quot;red&quot;,&quot;blue&quot;))+ xlim(-10,10)+ theme_bw() "],["loops.html", "5.4 Loops", " 5.4 Loops Iteration of a set of values with: for (var in seq) expr while (cond) expr repeat expr break next for (item in vector) perform_action ? for (variable in vector) { } First example for(i in 1:5) { print(1:i) } #&gt; [1] 1 #&gt; [1] 1 2 #&gt; [1] 1 2 3 #&gt; [1] 1 2 3 4 #&gt; [1] 1 2 3 4 5 Second example: terminate a for loop earlier for (i in 1:10) { if (i &lt; 3) next print(i) if (i &gt;= 5) break } #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 More tools while(condition) action: performs action while condition is TRUE. repeat(action): repeats action forever (i.e.¬†until it encounters break). Generally speaking you shouldn‚Äôt need to use for loops for data analysis tasks, as map() and apply() already provide less flexible solutions to most problems. You‚Äôll learn more in Chapter 9. "],["meeting-videos-4.html", "5.5 Meeting Videos", " 5.5 Meeting Videos 5.5.1 Cohort 1 5.5.2 Cohort 2 5.5.3 Cohort 3 5.5.4 Cohort 4 5.5.5 Cohort 5 5.5.6 Cohort 6 Meeting chat log 00:16:34 Federica Gazzelloni: https://github.com/r4ds/bookclub-Advanced_R 00:22:28 Federica Gazzelloni: https://stackoverflow.com/questions/50646133/dplyr-if-else-vs-base-r-ifelse 00:26:20 Trevin: case_when() is great, makes it easy to read 00:54:01 Trevin: out[I, ] 00:54:14 Trevin: out[i, ] 00:55:03 Trevin: I think you have to specify number of rows and columns before.. 00:55:30 Trevin: iterations = 10 variables = 2 output &lt;- matrix(ncol=variables, nrow=iterations) 00:55:43 Trevin: https://stackoverflow.com/questions/13442461/populating-a-data-frame-in-r-in-a-loop "],["functions.html", "Chapter 6 Functions", " Chapter 6 Functions Learning objectives: How to make functions in R What are the parts of a function Nested functions "],["how-to-make-a-simple-function-in-r.html", "6.1 How to make a simple function in R", " 6.1 How to make a simple function in R Let‚Äôs imagine the structure of a function: Figure 6.1: The black dot on the left is the environment. The two blocks to the right are the function arguments. Function components Functions have three parts, formals(), body(), and environment(). Example coffee_ratings%&gt;%slice(1:3)%&gt;%select(1:5) #&gt; # A tibble: 3 √ó 5 #&gt; total_cup_points species owner country_of_origin farm_name #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 90.6 Arabica metad plc Ethiopia &quot;metad pl‚Ä¶ #&gt; 2 89.9 Arabica metad plc Ethiopia &quot;metad pl‚Ä¶ #&gt; 3 89.8 Arabica grounds for health admin Guatemala &quot;san marc‚Ä¶ avg_points &lt;- function(species){ # this function is for calculating the mean avg &lt;- coffee_ratings %&gt;% filter(species == species) %&gt;% summarise(mean = mean(total_cup_points)) return(avg) } avg_points(&quot;Arabica&quot;) #&gt; # A tibble: 1 √ó 1 #&gt; mean #&gt; &lt;dbl&gt; #&gt; 1 82.1 formals(avg_points) #&gt; $species body(avg_points) #&gt; { #&gt; avg &lt;- coffee_ratings %&gt;% filter(species == species) %&gt;% #&gt; summarise(mean = mean(total_cup_points)) #&gt; return(avg) #&gt; } environment(avg_points) #&gt; &lt;environment: R_GlobalEnv&gt; Functions uses attributes, one attribute used by base R is srcref, short for source reference. It points to the source code used to create the function. It contains code comments and other formatting. attr(avg_points, &quot;srcref&quot;) #&gt; function(species){ #&gt; # this function is for calculating the mean #&gt; avg &lt;- coffee_ratings %&gt;% #&gt; filter(species == species) %&gt;% #&gt; summarise(mean = mean(total_cup_points)) #&gt; #&gt; return(avg) #&gt; } "],["primitive-functions.html", "6.2 Primitive functions", " 6.2 Primitive functions Are the core function in base R, such as sum() sum #&gt; function (..., na.rm = FALSE) .Primitive(&quot;sum&quot;) Type of primitives: builtin special typeof(sum) #&gt; [1] &quot;builtin&quot; These core functions have components to NULL. "],["anonymous-functions.html", "6.3 Anonymous functions", " 6.3 Anonymous functions If you don‚Äôt provide a name to a function lapply(mtcars%&gt;%select(mpg,cyl), function(x) length(unique(x))) #&gt; $mpg #&gt; [1] 25 #&gt; #&gt; $cyl #&gt; [1] 3 vector_len &lt;- function(x) { length(unique(x)) } lapply(mtcars%&gt;%select(mpg,cyl), vector_len) #&gt; $mpg #&gt; [1] 25 #&gt; #&gt; $cyl #&gt; [1] 3 Invoking a function args &lt;- unique(coffee_ratings$species) %&gt;% `[[`(1) %&gt;% as.list() do.call(avg_points, args) #&gt; # A tibble: 1 √ó 1 #&gt; mean #&gt; &lt;dbl&gt; #&gt; 1 82.1 "],["function-composition.html", "6.4 Function composition", " 6.4 Function composition square &lt;- function(x) x^2 deviation &lt;- function(x) x - mean(x) x &lt;- runif(100) sqrt(mean(square(deviation(x)))) #&gt; [1] 0.2812728 out &lt;- deviation(x) out &lt;- square(out) out &lt;- mean(out) out &lt;- sqrt(out) out #&gt; [1] 0.2812728 x %&gt;% deviation() %&gt;% square() %&gt;% mean() %&gt;% sqrt() #&gt; [1] 0.2812728 "],["more-about-functions-insights.html", "6.5 More about functions insights", " 6.5 More about functions insights 6.5.1 Lexical scoping Rules Name masking Functions versus variables A fresh start Dynamic lookup Debugging This function g12 &lt;- function() x + 1 x &lt;- 15 g12() #&gt; [1] 16 codetools::findGlobals(g12) #&gt; [1] &quot;+&quot; &quot;x&quot; You can change the function‚Äôs environment to an environment which contains nothing: # environment(g12) &lt;- emptyenv() # g12() # Error in x + 1 : could not find function &quot;+&quot; 6.5.2 ‚Ä¶ (dot-dot-dot) Example i01 &lt;- function(y, z) { list(y = y, z = z) } i02 &lt;- function(x, ...) { i01(...) } str(i02(x = 1, y = 2, z = 3)) #&gt; List of 2 #&gt; $ y: num 2 #&gt; $ z: num 3 #&gt; List of 2 #&gt; $ y: num 2 #&gt; $ z: num 3 6.5.3 Exiting a function Implicit or explicit returns Invisibility (&lt;- most famous function that returns an invisible value) stop() to stop a function with an error. Exit handlers 6.5.4 Function forms Everything that exists is an object. Everything that happens is a function call. ‚Äî John Chambers "],["case-study-sir-model-function.html", "6.6 Case Study: SIR model function", " 6.6 Case Study: SIR model function This is an interesting example taken from a course on Coursera: Infectious disease modelling-ICL The purpose of this example is to show how to make a model passing through making a function. First we need to load some useful libraries: library(deSolve) library(reshape2) Then set the model inputs: population size (N) number of susceptable (S) infected (I) recovered (R) And add the model parameters: infection rate (\\(\\beta\\)) recovery rate (\\(\\gamma\\)) N&lt;- 100000 # population state_values&lt;- c(S = N -1, # susceptible I = 1, # infected R = 0) # recovered parameters&lt;- c(beta = 1/2, # infection rate days^-1 gamma = 1/4) # recovery rate days^-1 Then we set the time as an important factor, which defines the length of time we are looking at this model run. It is intended as the time range in which the infections spread out, let‚Äôs say that we are aiming to investigate an infection period of 100 days. times&lt;- seq(0, 100, by = 1) Finally, we set up the SIR model, the susceptable, infected and recovered model. How do we do that is passing the paramenters through a function of the time, and state. Within the model function we calculate one more paramenter, the force of infection: \\(\\lambda\\) sir_model&lt;- function(time, state, parameters){ with(as.list(c(state, parameters)),{ N&lt;- S + I + R lambda = beta * I/N # force of infection dS&lt;- - lambda * S dI&lt;- lambda * S - gamma * I dR&lt;- gamma * I return(list(c(dS,dI,dR))) }) } Once we have our SIR model function ready, we can calculate the output of the model, with the help of the function ode() from {deSolve} package. output&lt;- as.data.frame(ode(y = state_values, times = times, func = sir_model, parms = parameters)) output %&gt;% head #&gt; time S I R #&gt; 1 0 99999.00 1.000000 0.0000000 #&gt; 2 1 99998.43 1.284018 0.2840252 #&gt; 3 2 99997.70 1.648696 0.6487171 #&gt; 4 3 99996.77 2.116939 1.1169863 #&gt; 5 4 99995.56 2.718152 1.7182450 #&gt; 6 5 99994.02 3.490086 2.4902600 In addition to our builtin SIR model function we can have a look at: ?deSolve::ode() It solves Ordinary Differential Equations. deSolve:::ode #&gt; function (y, times, func, parms, method = c(&quot;lsoda&quot;, &quot;lsode&quot;, #&gt; &quot;lsodes&quot;, &quot;lsodar&quot;, &quot;vode&quot;, &quot;daspk&quot;, &quot;euler&quot;, &quot;rk4&quot;, &quot;ode23&quot;, #&gt; &quot;ode45&quot;, &quot;radau&quot;, &quot;bdf&quot;, &quot;bdf_d&quot;, &quot;adams&quot;, &quot;impAdams&quot;, &quot;impAdams_d&quot;, #&gt; &quot;iteration&quot;), ...) #&gt; { #&gt; if (is.null(method)) #&gt; method &lt;- &quot;lsoda&quot; #&gt; if (is.list(method)) { #&gt; if (!inherits(method, &quot;rkMethod&quot;)) #&gt; stop(&quot;&#39;method&#39; should be given as string or as a list of class &#39;rkMethod&#39;&quot;) #&gt; out &lt;- rk(y, times, func, parms, method = method, ...) #&gt; } #&gt; else if (is.function(method)) #&gt; out &lt;- method(y, times, func, parms, ...) #&gt; else if (is.complex(y)) #&gt; out &lt;- switch(match.arg(method), vode = zvode(y, times, #&gt; func, parms, ...), bdf = zvode(y, times, func, parms, #&gt; mf = 22, ...), bdf_d = zvode(y, times, func, parms, #&gt; mf = 23, ...), adams = zvode(y, times, func, parms, #&gt; mf = 10, ...), impAdams = zvode(y, times, func, parms, #&gt; mf = 12, ...), impAdams_d = zvode(y, times, func, #&gt; parms, mf = 13, ...)) #&gt; else out &lt;- switch(match.arg(method), lsoda = lsoda(y, times, #&gt; func, parms, ...), vode = vode(y, times, func, parms, #&gt; ...), lsode = lsode(y, times, func, parms, ...), lsodes = lsodes(y, #&gt; times, func, parms, ...), lsodar = lsodar(y, times, func, #&gt; parms, ...), daspk = daspk(y, times, func, parms, ...), #&gt; euler = rk(y, times, func, parms, method = &quot;euler&quot;, ...), #&gt; rk4 = rk(y, times, func, parms, method = &quot;rk4&quot;, ...), #&gt; ode23 = rk(y, times, func, parms, method = &quot;ode23&quot;, ...), #&gt; ode45 = rk(y, times, func, parms, method = &quot;ode45&quot;, ...), #&gt; radau = radau(y, times, func, parms, ...), bdf = lsode(y, #&gt; times, func, parms, mf = 22, ...), bdf_d = lsode(y, #&gt; times, func, parms, mf = 23, ...), adams = lsode(y, #&gt; times, func, parms, mf = 10, ...), impAdams = lsode(y, #&gt; times, func, parms, mf = 12, ...), impAdams_d = lsode(y, #&gt; times, func, parms, mf = 13, ...), iteration = iteration(y, #&gt; times, func, parms, ...)) #&gt; return(out) #&gt; } #&gt; &lt;bytecode: 0x55e81f2402e0&gt; #&gt; &lt;environment: namespace:deSolve&gt; methods(&quot;ode&quot;) #&gt; Warning in .S3methods(generic.function, class, envir): function &#39;ode&#39; appears #&gt; not to be S3 generic; found functions that look like S3 methods #&gt; [1] ode.1D ode.2D ode.3D ode.band #&gt; see &#39;?methods&#39; for accessing help and source code With the help of the {reshape2} package we use the function melt() to reshape the output: melt(output,id=&quot;time&quot;) %&gt;% head #&gt; time variable value #&gt; 1 0 S 99999.00 #&gt; 2 1 S 99998.43 #&gt; 3 2 S 99997.70 #&gt; 4 3 S 99996.77 #&gt; 5 4 S 99995.56 #&gt; 6 5 S 99994.02 The same as usign pivot_longer() function. output%&gt;% pivot_longer(cols = c(&quot;S&quot;,&quot;I&quot;,&quot;R&quot;), names_to=&quot;variable&quot;, values_to=&quot;values&quot;) %&gt;% arrange(desc(variable)) %&gt;% head #&gt; # A tibble: 6 √ó 3 #&gt; time variable values #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 0 S 99999 #&gt; 2 1 S 99998. #&gt; 3 2 S 99998. #&gt; 4 3 S 99997. #&gt; 5 4 S 99996. #&gt; 6 5 S 99994. Before to proceed with the visualization of the SIR model output we do a bit of investigations. What if we want to see how melt() function works? What instruments we can use to see inside the function and understand how it works? Using just the function name melt or structure() function with melt as an argument, we obtain the same output. To select just the argument of the function we can do args(melt) reshape2:::melt #&gt; function (data, ..., na.rm = FALSE, value.name = &quot;value&quot;) #&gt; { #&gt; UseMethod(&quot;melt&quot;, data) #&gt; } #&gt; &lt;bytecode: 0x55e81a9634c8&gt; #&gt; &lt;environment: namespace:reshape2&gt; body(melt) #&gt; { #&gt; UseMethod(&quot;melt&quot;, data) #&gt; } formals(melt) #&gt; $data #&gt; #&gt; #&gt; $... #&gt; #&gt; #&gt; $na.rm #&gt; [1] FALSE #&gt; #&gt; $value.name #&gt; [1] &quot;value&quot; environment(melt) #&gt; &lt;environment: namespace:reshape2&gt; typeof(melt) #&gt; [1] &quot;closure&quot; ‚ÄúR functions simulate a closure by keeping an explicit reference to the environment that was active when the function was defined.‚Äù ref: closures Try with methods(), or print(methods(melt)): Non-visible functions are asterisked! The S3 method name is followed by an asterisk * if the method definition is not exported from the package namespace in which the method is defined. methods(&quot;melt&quot;, data) #&gt; [1] melt.array* melt.data.frame* melt.default* melt.list* #&gt; [5] melt.matrix* melt.table* #&gt; see &#39;?methods&#39; for accessing help and source code methods(class=&quot;table&quot;) #&gt; [1] [ aperm as_tibble as.data.frame Axis #&gt; [6] coerce initialize lines melt plot #&gt; [11] points print show slotsFromS3 summary #&gt; [16] tail #&gt; see &#39;?methods&#39; for accessing help and source code help(UseMethod) We can access to some of the above calls with getAnywhere(), for example here is done for ‚Äúmelt.data.frame‚Äù: getAnywhere(&quot;melt.data.frame&quot;) #&gt; A single object matching &#39;melt.data.frame&#39; was found #&gt; It was found in the following places #&gt; registered S3 method for melt from namespace reshape2 #&gt; namespace:reshape2 #&gt; with value #&gt; #&gt; function (data, id.vars, measure.vars, variable.name = &quot;variable&quot;, #&gt; ..., na.rm = FALSE, value.name = &quot;value&quot;, factorsAsStrings = TRUE) #&gt; { #&gt; vars &lt;- melt_check(data, id.vars, measure.vars, variable.name, #&gt; value.name) #&gt; id.ind &lt;- match(vars$id, names(data)) #&gt; measure.ind &lt;- match(vars$measure, names(data)) #&gt; if (!length(measure.ind)) { #&gt; return(data[id.vars]) #&gt; } #&gt; args &lt;- normalize_melt_arguments(data, measure.ind, factorsAsStrings) #&gt; measure.attributes &lt;- args$measure.attributes #&gt; factorsAsStrings &lt;- args$factorsAsStrings #&gt; valueAsFactor &lt;- &quot;factor&quot; %in% measure.attributes$class #&gt; df &lt;- melt_dataframe(data, as.integer(id.ind - 1), as.integer(measure.ind - #&gt; 1), as.character(variable.name), as.character(value.name), #&gt; as.pairlist(measure.attributes), as.logical(factorsAsStrings), #&gt; as.logical(valueAsFactor)) #&gt; if (na.rm) { #&gt; return(df[!is.na(df[[value.name]]), ]) #&gt; } #&gt; else { #&gt; return(df) #&gt; } #&gt; } #&gt; &lt;bytecode: 0x55e81bf7e9f0&gt; #&gt; &lt;environment: namespace:reshape2&gt; References: stackoverflow article Rnews bulletin: R Help Desk Going back to out model output visualization. output_full&lt;- melt(output,id=&quot;time&quot;) output_full$proportion&lt;- output_full$value/sum(state_values) ggplot(data = output, aes(x = time, y = I)) + geom_line() + xlab(&quot;Time(days)&quot;) + ylab(&quot;Number of Infected&quot;) + labs(&quot;SIR Model: prevalence of infection&quot;) ggplot(output_full, aes(time, proportion, color = variable, group = variable)) + geom_line() + xlab(&quot;Time(days)&quot;) + ylab(&quot;Prevalence&quot;) + labs(color = &quot;Compartment&quot;, title = &quot;SIR Model&quot;) "],["meeting-videos-5.html", "6.7 Meeting Videos", " 6.7 Meeting Videos 6.7.1 Cohort 1 6.7.2 Cohort 2 6.7.3 Cohort 3 6.7.4 Cohort 4 6.7.5 Cohort 5 6.7.6 Cohort 6 Meeting chat log 00:01:11 Oluwafemi Oyedele: Hi, Good evening 00:01:22 Federica Gazzelloni: Hello! 00:43:19 Federica Gazzelloni: https://r4ds.github.io/bookclub-Advanced_R/QandA/docs/welcome.html 00:52:48 Priyanka: sounds good actually 00:52:59 Federica Gazzelloni: üëçüèª Meeting chat log 00:09:30 Oluwafemi Oyedele: Hi, Good evening 00:10:41 Federica Gazzelloni: Hi 00:14:40 Federica Gazzelloni: that&#39;s great! 00:54:24 Trevin: Also, sorry if you are repeating üôÇ 00:54:52 Arthur Shaw: @ryan, thank you so much for the awesome synthesis! Could you share your reference list? I&#39;d love to dive more deeply into the material you presented. 00:57:02 Ryan Metcalf: https://cran.r-project.org/doc/manuals/r-release/R-lang.pdf 00:59:32 Trevin: https://github.com/COHHIO/RmData 01:01:48 Ryan Metcalf: https://mastering-shiny.org/ 01:02:02 Ryan Metcalf: https://engineering-shiny.org/ 01:02:15 Arthur Shaw: @trevin, if you get bored with beepr, move to BRRR ;) 01:02:16 Arthur Shaw: https://github.com/brooke-watson/BRRR 01:09:27 Ryan Metcalf: This is amazing Trevin! I&#39;ll take a closer look. Is it ok to reach out to you with any questions? 01:09:43 Trevin: Yeah, feel free to reach out Meeting chat log 00:05:34 Trevin: I didn&#39;t catch that 00:06:02 priyanka gagneja: i won&#39;t be presenting I said .. so you two have the stage 00:08:39 Federica Gazzelloni: no worries 00:08:46 Federica Gazzelloni: next time you do it 00:08:56 Federica Gazzelloni: did you sign up? 00:09:45 Trevin: Discord is free: https://discord.gg/rstudioconf2022 00:10:04 Trevin: Free stream link: https://www.rstudio.com/conference/stream 00:24:32 Arthur Shaw: Maybe silly question: is the magrittr pipe an infix function? 00:32:15 Trevin: https://colinfay.me/playing-r-infix-functions/ 00:33:23 Arthur Shaw: Maybe another example of an infix function: lubridate&#39;s `%within%` 00:33:47 Trevin: That&#39;s a good one too ^ 00:33:55 priyanka gagneja: yes within would be good. 00:40:13 Arthur Shaw: no 00:49:50 Arthur Shaw: Sorry for dropping in and out. My WiFi router is having issues today--maybe is failing. 01:08:59 Trevin: Looking forward to it üôÇ "],["environments.html", "Chapter 7 Environments", " Chapter 7 Environments Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-1.html", "7.1 SLIDE 1", " 7.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-6.html", "7.2 Meeting Videos", " 7.2 Meeting Videos 7.2.1 Cohort 1 7.2.2 Cohort 2 7.2.3 Cohort 3 7.2.4 Cohort 4 7.2.5 Cohort 5 7.2.6 Cohort 6 Meeting chat log LOG "],["conditions.html", "Chapter 8 Conditions", " Chapter 8 Conditions Learning objectives: What conditions are How to use them "],["introduction-2.html", "8.1 Introduction", " 8.1 Introduction What are conditions? Problems that happen in functions: Error Warning Message As a function author, one can signal them‚Äìthat is, say there‚Äôs a problem. As a function consumer, one can handle them‚Äìfor example, react or ignore. "],["signalling-conditions.html", "8.2 Signalling conditions", " 8.2 Signalling conditions 8.2.1 Types of conditions Three types of conditions: ‚ùå Errors. Problem arose, and the function cannot continue. ‚ö†Ô∏è Warnings. Problem arose, but the function can continue, if only partially. üí¨ Messages. Something happened, and the user should know. 8.2.2 ‚ùå Errors How to throw errors # with base R stop(&quot;... in the name of love...&quot;) #&gt; Error in eval(expr, envir, enclos): ... in the name of love... # with rlang rlang::abort(&quot;...before you break my heart...&quot;) #&gt; Error: #&gt; ! ...before you break my heart... # with base R; without call stop(&quot;... think it o-o-over...&quot;, call. = FALSE) #&gt; Error: ... think it o-o-over... Composing error messages Mechanics. stop() pastes together arguments some_val &lt;- 1 stop(&quot;Your value is: &quot;, some_val, call. = FALSE) #&gt; Error: Your value is: 1 abort() requires {glue} some_val &lt;- 1 rlang::abort(glue::glue(&quot;Your value is: {some_val}&quot;)) #&gt; Error: #&gt; ! Your value is: 1 Style. See here. 8.2.3 ‚ö†Ô∏è Warnings May have multiple warnings per call warn &lt;- function() { warning(&quot;This is your first warning&quot;) warning(&quot;This is your second warning&quot;) warning(&quot;This is your LAST warning&quot;) } Print all warnings once call is complete. warn() #&gt; Warning in warn(): This is your first warning #&gt; Warning in warn(): This is your second warning #&gt; Warning in warn(): This is your LAST warning Like errors, warning() has a call argument an {rlang} analog # base R # ... with call (implicitly .call = TRUE) warning(&quot;Warning&quot;) #&gt; Warning: Warning # ... with call suppressed warning(&quot;Warning&quot;, call. = FALSE) #&gt; Warning: Warning # rlang # note: call suppressed by default rlang::warn(&quot;Warning&quot;) #&gt; Warning: Warning (Hadley‚Äôs) advice on usage: Err on the side of errors. In other words, error rather than warn. But warnings make sense in a few cases: Function is being deprecated. Warn that it is reaching end of life. Function is reasonably sure to recover from issue. 8.2.4 üí¨ Messages Mechanics: Issued immediately Do not have a call argument Style: Messages are best when they inform about: Default arguments Status updates of for functions used primarily for side-effects (e.g., interaction with web API, file downloaded, etc.) Progress of long-running process (in the absence of a status bar). Package loading message (e.g., attaching package, objects masked) "],["ignoring-conditions.html", "8.3 Ignoring conditions", " 8.3 Ignoring conditions A few ways: try() suppressWarnings() suppressMessages() 8.3.1 try() What it does: Displays error But continues execution after error bad_log &lt;- function(x) { try(log(x)) 10 } bad_log(&quot;bad&quot;) #&gt; Error in log(x) : non-numeric argument to mathematical function #&gt; [1] 10 Better ways to react to/recover from errors: Use tryCatch() to ‚Äúcatch‚Äù the error and perform a different action in the event of an error. Set a default value inside the call. See below. default &lt;- NULL try(default &lt;- read.csv(&quot;possibly-bad-input.csv&quot;), silent = TRUE) #&gt; Warning in file(file, &quot;rt&quot;): cannot open file &#39;possibly-bad-input.csv&#39;: No such #&gt; file or directory 8.3.2 suppressWarnings(), suppressMessages() What it does: Supresses all warnings (messages) # suppress warnings (from our `warn()` function above) suppressWarnings(warn()) # suppress messages many_messages &lt;- function() { message(&quot;Message 1&quot;) message(&quot;Message 2&quot;) message(&quot;Message 3&quot;) } suppressMessages(many_messages()) "],["handling-conditions.html", "8.4 Handling conditions", " 8.4 Handling conditions Every condition has a default behavior: ‚ùå Errors halt execution ‚ö†Ô∏è Warnings are collected during execution and displayed in bulk after execution üí¨ Messages are displayed immediately Condition handlers allow one to change that behavior (within the scope of a function). Two handler functions: tryCatch() withCallingHandlers() # try to run `code_to_try_to_run` # if (error) condition is signalled, fun some other code tryCatch( error = function(cnd) { # code to run when error is thrown }, code_to_try_to_run ) # try to `code_to_try_to_run` # if condition is signalled, run code corresponding to condition type withCallingHandlers( warning = function(cnd) { # code to run when warning is signalled }, message = function(cnd) { # code to run when message is signalled }, code_to_try_to_run ) 8.4.1 Condition objects # catch a condition cnd &lt;- rlang::catch_cnd(stop(&quot;An error&quot;)) # inspect it str(cnd) #&gt; List of 2 #&gt; $ message: chr &quot;An error&quot; #&gt; $ call : language force(expr) #&gt; - attr(*, &quot;class&quot;)= chr [1:3] &quot;simpleError&quot; &quot;error&quot; &quot;condition&quot; The standard components message. The error message. To extract it, use conditionMessage(cnd). call. The function call that triggered the condition. To extract it, use conditionCall(cnd). But custom conditions may contain other components. 8.4.2 Exiting handlers If a condition is signalled, this type of handler controls what code to run before exiting the function call. f3 &lt;- function(x) { tryCatch( # if error signalled, return NA error = function(cnd) NA, # try to run log log(x) ) } f3(&quot;x&quot;) #&gt; [1] NA When a condition is signalled, control moves to the handler and never returns to the original code. tryCatch( message = function(cnd) &quot;There&quot;, { message(&quot;Here&quot;) stop(&quot;This code is never run!&quot;) } ) #&gt; [1] &quot;There&quot; The tryCatch() exit handler has one final argument: finally. This is run regardless of the condition of the original code. This is often used for clean-up. # try to write text to disk # if an error is signalled--for example, `path` does not exist # or if no condition is signalled # that is in both cases, the code block in `finally` is executed path &lt;- tempfile() tryCatch( { writeLines(&quot;Hi!&quot;, path) # ... }, finally = { # always run unlink(path) } ) 8.4.3 Calling handlers Definition by verbal comparison: With exit handlers, code exits the normal flow once a condition is signalled With calling handlers, code continues in the normal flow once control is returned by the handler. Definition by code comparison: # with an exit handler, control moves to the handler once condition signalled and does not move back tryCatch( message = function(cnd) cat(&quot;Caught a message!\\n&quot;), { message(&quot;Someone there?&quot;) message(&quot;Why, yes!&quot;) } ) #&gt; Caught a message! # with a calling handler, control moves first to the handler and the moves back to the main code withCallingHandlers( message = function(cnd) cat(&quot;Caught a message!\\n&quot;), { message(&quot;Someone there?&quot;) message(&quot;Why, yes!&quot;) } ) #&gt; Caught a message! #&gt; Someone there? #&gt; Caught a message! #&gt; Why, yes! 8.4.4 By default, conditions propagate Let‚Äôs suppose that there are nested handlers. If a condition is signalled in the child, it propagates to its parent handler(s). # Bubbles all the way up to default handler which generates the message withCallingHandlers( message = function(cnd) cat(&quot;Level 2\\n&quot;), withCallingHandlers( message = function(cnd) cat(&quot;Level 1\\n&quot;), message(&quot;Hello&quot;) ) ) #&gt; Level 1 #&gt; Level 2 #&gt; Hello # Bubbles up to tryCatch tryCatch( message = function(cnd) cat(&quot;Level 2\\n&quot;), withCallingHandlers( message = function(cnd) cat(&quot;Level 1\\n&quot;), message(&quot;Hello&quot;) ) ) #&gt; Level 1 #&gt; Level 2 8.4.5 But conditions can be muffled If one wants to ‚Äúmuffle‚Äù the siginal, one needs to use rlang::cnd_muffle() # Muffles the default handler which prints the messages withCallingHandlers( message = function(cnd) { cat(&quot;Level 2\\n&quot;) rlang::cnd_muffle(cnd) }, withCallingHandlers( message = function(cnd) cat(&quot;Level 1\\n&quot;), message(&quot;Hello&quot;) ) ) #&gt; Level 1 #&gt; Level 2 # Muffles level 2 handler and the default handler withCallingHandlers( message = function(cnd) cat(&quot;Level 2\\n&quot;), withCallingHandlers( message = function(cnd) { cat(&quot;Level 1\\n&quot;) rlang::cnd_muffle(cnd) }, message(&quot;Hello&quot;) ) ) #&gt; Level 1 8.4.6 Call stacks Call stacks of exiting and calling handlers differ. Why? Calling handlers are called in the context of the call that signalled the condition exiting handlers are called in the context of the call to tryCatch() To see this, consider how the call stacks differ for a toy example. # create a function f &lt;- function() g() g &lt;- function() h() h &lt;- function() message # call stack of calling handlers withCallingHandlers(f(), message = function(cnd) { lobstr::cst() rlang::cnd_muffle(cnd) }) #&gt; function (..., domain = NULL, appendLF = TRUE) #&gt; { #&gt; cond &lt;- if (...length() == 1L &amp;&amp; inherits(..1, &quot;condition&quot;)) { #&gt; if (nargs() &gt; 1L) #&gt; warning(&quot;additional arguments ignored in message()&quot;) #&gt; ..1 #&gt; } #&gt; else { #&gt; msg &lt;- .makeMessage(..., domain = domain, appendLF = appendLF) #&gt; call &lt;- sys.call() #&gt; simpleMessage(msg, call) #&gt; } #&gt; defaultHandler &lt;- function(c) { #&gt; cat(conditionMessage(c), file = stderr(), sep = &quot;&quot;) #&gt; } #&gt; withRestarts({ #&gt; signalCondition(cond) #&gt; defaultHandler(cond) #&gt; }, muffleMessage = function() NULL) #&gt; invisible() #&gt; } #&gt; &lt;bytecode: 0x55e8175b3610&gt; #&gt; &lt;environment: namespace:base&gt; # call stack of exit handlers tryCatch(f(), message = function(cnd) lobstr::cst()) #&gt; function (..., domain = NULL, appendLF = TRUE) #&gt; { #&gt; cond &lt;- if (...length() == 1L &amp;&amp; inherits(..1, &quot;condition&quot;)) { #&gt; if (nargs() &gt; 1L) #&gt; warning(&quot;additional arguments ignored in message()&quot;) #&gt; ..1 #&gt; } #&gt; else { #&gt; msg &lt;- .makeMessage(..., domain = domain, appendLF = appendLF) #&gt; call &lt;- sys.call() #&gt; simpleMessage(msg, call) #&gt; } #&gt; defaultHandler &lt;- function(c) { #&gt; cat(conditionMessage(c), file = stderr(), sep = &quot;&quot;) #&gt; } #&gt; withRestarts({ #&gt; signalCondition(cond) #&gt; defaultHandler(cond) #&gt; }, muffleMessage = function() NULL) #&gt; invisible() #&gt; } #&gt; &lt;bytecode: 0x55e8175b3610&gt; #&gt; &lt;environment: namespace:base&gt; tryCatch(f(), message = function(cnd) lobstr::cst()) #&gt; function (..., domain = NULL, appendLF = TRUE) #&gt; { #&gt; cond &lt;- if (...length() == 1L &amp;&amp; inherits(..1, &quot;condition&quot;)) { #&gt; if (nargs() &gt; 1L) #&gt; warning(&quot;additional arguments ignored in message()&quot;) #&gt; ..1 #&gt; } #&gt; else { #&gt; msg &lt;- .makeMessage(..., domain = domain, appendLF = appendLF) #&gt; call &lt;- sys.call() #&gt; simpleMessage(msg, call) #&gt; } #&gt; defaultHandler &lt;- function(c) { #&gt; cat(conditionMessage(c), file = stderr(), sep = &quot;&quot;) #&gt; } #&gt; withRestarts({ #&gt; signalCondition(cond) #&gt; defaultHandler(cond) #&gt; }, muffleMessage = function() NULL) #&gt; invisible() #&gt; } #&gt; &lt;bytecode: 0x55e8175b3610&gt; #&gt; &lt;environment: namespace:base&gt; "],["custom-conditions.html", "8.5 Custom conditions", " 8.5 Custom conditions 8.5.1 Motivation The base::log() function provides a minimal error message. log(letters) #&gt; Error in log(letters): non-numeric argument to mathematical function log(1:10, base = letters) #&gt; Error in log(1:10, base = letters): non-numeric argument to mathematical function One could make a more informative error message about which argument is problematic. my_log &lt;- function(x, base = exp(1)) { if (!is.numeric(x)) { rlang::abort(paste0( &quot;`x` must be a numeric vector; not &quot;, typeof(x), &quot;.&quot; )) } if (!is.numeric(base)) { rlang::abort(paste0( &quot;`base` must be a numeric vector; not &quot;, typeof(base), &quot;.&quot; )) } base::log(x, base = base) } Consider the difference: my_log(letters) #&gt; Error in `my_log()`: #&gt; ! `x` must be a numeric vector; not character. my_log(1:10, base = letters) #&gt; Error in `my_log()`: #&gt; ! `base` must be a numeric vector; not character. 8.5.2 Signalling Create a helper function to describe errors: abort_bad_argument &lt;- function(arg, must, not = NULL) { msg &lt;- glue::glue(&quot;`{arg}` must {must}&quot;) if (!is.null(not)) { not &lt;- typeof(not) msg &lt;- glue::glue(&quot;{msg}; not {not}.&quot;) } rlang::abort( &quot;error_bad_argument&quot;, # &lt;- this is the (error) class, I believe message = msg, arg = arg, must = must, not = not ) } Rewrite the log function to use this helper function: my_log &lt;- function(x, base = exp(1)) { if (!is.numeric(x)) { abort_bad_argument(&quot;x&quot;, must = &quot;be numeric&quot;, not = x) } if (!is.numeric(base)) { abort_bad_argument(&quot;base&quot;, must = &quot;be numeric&quot;, not = base) } base::log(x, base = base) } See the result for the end user: my_log(letters) #&gt; Error in `abort_bad_argument()`: #&gt; ! `x` must be numeric; not character. my_log(1:10, base = letters) #&gt; Error in `abort_bad_argument()`: #&gt; ! `base` must be numeric; not character. 8.5.3 Handling Use class of condition object to allow for different handling of different types of errors tryCatch( error_bad_argument = function(cnd) &quot;bad_argument&quot;, error = function(cnd) &quot;other error&quot;, my_log(&quot;a&quot;) ) #&gt; [1] &quot;bad_argument&quot; But note that the first handler that matches any of the signal‚Äôs class, potentially in a vector of signal classes, will get control. So put the most specific handlers first. "],["applications-1.html", "8.6 Applications", " 8.6 Applications See the sub-section in the book for excellent examples. "],["resources-1.html", "8.7 Resources", " 8.7 Resources Conditions articles in rlang vignettes: Including function calls in error messages Including contextual information with error chains Formatting messages with cli Other resources from error message segment of rstudio::conf(2022) workshop ‚ÄúPackage Development Masterclass‚Äù "],["meeting-videos-7.html", "8.8 Meeting Videos", " 8.8 Meeting Videos 8.8.1 Cohort 1 8.8.2 Cohort 2 8.8.3 Cohort 3 8.8.4 Cohort 4 8.8.5 Cohort 5 8.8.6 Cohort 6 Meeting chat log LOG "],["functionals.html", "Chapter 9 Functionals", " Chapter 9 Functionals Learning objectives: Define functionals. Use the purrr::map() family of functionals. Use the purrr::walk() family of functionals. Use the purrr::reduce() and purrr::accumulate() family of functionals. Use purrr::safely() and purrr::possibly() to deal with failure. 9.1. Introduction 9.2. map() 9.3. purrr style 9.4. map_ variants 9.5. reduce() and accumulate family of functions Some functions that weren‚Äôt covered "],["what-are-functionals.html", "What are functionals", " What are functionals "],["introduction-3.html", "9.1 Introduction", " 9.1 Introduction Functionals are functions that take function as input and return a vector as output. Functionals that you probably have used before are: apply(), lapply() or tapply(). alternatives to loops a functional is better than a for loop is better than while is better than repeat Benefits encourages function logic to be separated from iteration logic can collapse into vectors/data frames easily "],["map.html", "9.2 Map", " 9.2 Map map() has two arguments, a vector and a function. It performs the function on each element of the vector and returns a list. We can also pass in some additional argument into the function. simple_map &lt;- function(x, f, ...) { out &lt;- vector(&quot;list&quot;, length(x)) for (i in seq_along(x)) { out[[i]] &lt;- f(x[[i]], ...) } out } "],["benefit-of-using-the-map-function-in-purrr.html", "Benefit of using the map function in purrr", " Benefit of using the map function in purrr purrr::map() is equivalent to lapply() returns a list and is the most general the length of the input == the length of the output "],["atomic-vectors-2.html", "Atomic vectors", " Atomic vectors has 4 variants to return atomic vectors map_chr() map_dbl() map_int() map_lgl() triple &lt;- function(x) x * 3 map(.x=1:3, .f=triple) #&gt; [[1]] #&gt; [1] 3 #&gt; #&gt; [[2]] #&gt; [1] 6 #&gt; #&gt; [[3]] #&gt; [1] 9 map_dbl(.x=1:3, .f=triple) #&gt; [1] 3 6 9 map_lgl(.x=c(1, NA, 3), .f=is.na) #&gt; [1] FALSE TRUE FALSE "],["anonymous-functions-and-shortcuts.html", "Anonymous functions and shortcuts", " Anonymous functions and shortcuts Anonymous functions map_dbl(.x=mtcars, .f=function(x) mean(x, na.rm = TRUE)) %&gt;% head() #&gt; mpg cyl disp hp drat wt #&gt; 20.090625 6.187500 230.721875 146.687500 3.596563 3.217250 the ‚Äútwiddle‚Äù uses a twiddle ~ to set a formula can use .x to reference the input map(.x = ..., .f = ) map_dbl(.x=mtcars, .f=~mean(.x, na.rm = TRUE)) can be simplified further as map_dbl(.x=mtcars, .f=mean, na.rm = TRUE) #&gt; mpg cyl disp hp drat wt qsec #&gt; 20.090625 6.187500 230.721875 146.687500 3.596563 3.217250 17.848750 #&gt; vs am gear carb #&gt; 0.437500 0.406250 3.687500 2.812500 "],["modify.html", "Modify", " Modify Sometimes we might want the output to be the same as the input, then in that case we can use the modify function rather than map df &lt;- data.frame(x=1:3,y=6:4) map(df, .f=~.x*3) #&gt; $x #&gt; [1] 3 6 9 #&gt; #&gt; $y #&gt; [1] 18 15 12 modify(.x=df,.f=~.x*3) #&gt; x y #&gt; 1 3 18 #&gt; 2 6 15 #&gt; 3 9 12 "],["purrr-style.html", "9.3 purrr style", " 9.3 purrr style mtcars %&gt;% map(head, 20) %&gt;% # pull first 20 of each column map_dbl(mean) %&gt;% # mean of each vector head() #&gt; mpg cyl disp hp drat wt #&gt; 20.13000 6.20000 233.93000 136.20000 3.54500 3.39845 An example from tidytuesday tt &lt;- tidytuesdayR::tt_load(&quot;2020-06-30&quot;) # filter data &amp; exclude columns with lost of nulls list_df &lt;- map( .x = tt[1:3], .f = ~ .x %&gt;% filter(issue &lt;= 152 | issue &gt; 200) %&gt;% mutate(timeframe = ifelse(issue &lt;= 152, &quot;first 5 years&quot;, &quot;last 5 years&quot;)) %&gt;% select_if(~mean(is.na(.)) &lt; 0.2) ) # write to global environment iwalk( .x = list_df, .f = ~ assign(x = .y, value = .x, envir = globalenv()) ) "],["map_-variants.html", "9.4 map_*() variants", " 9.4 map_*() variants There are many variants "],["map2_.html", "map2_*()", " map2_*() raise each value .x by 2 map_dbl( .x = 1:5, .f = function(x) x ^ 2 ) #&gt; [1] 1 4 9 16 25 raise each value .x by another value .y map2_dbl( .x = 1:5, .y = 2:6, .f = ~ (.x ^ .y) ) #&gt; [1] 1 8 81 1024 15625 "],["the-benefit-of-using-the-map-over-apply-family-of-function.html", "The benefit of using the map over apply family of function", " The benefit of using the map over apply family of function It is written in C It preserves names We always know the return values We can apply function into multiple input value We can pass in some additional arguments to the function "],["walk.html", "walk()", " walk() We use walk when we want to call a function for it side effect rather than it return value, like generating plots, write.csv() or ggsave(), map() will print more info than you may want map(1:3, ~cat(.x, &quot;\\n&quot;)) #&gt; 1 #&gt; 2 #&gt; 3 #&gt; [[1]] #&gt; NULL #&gt; #&gt; [[2]] #&gt; NULL #&gt; #&gt; [[3]] #&gt; NULL for these cases, use walk() instead walk(1:3, ~cat(.x, &quot;\\n&quot;)) #&gt; 1 #&gt; 2 #&gt; 3 We can use pwalk to save a list of plot to disk plots &lt;- mtcars %&gt;% split(.$cyl) %&gt;% map(~ggplot(.,aes(mpg,wt))+geom_point()) paths &lt;- stringr::str_c(names(plots),&#39;.png&#39;) pwalk(.l=list(paths,plots),.f=ggsave,path=tempdir()) #&gt; Saving 7 x 5 in image #&gt; Saving 7 x 5 in image #&gt; Saving 7 x 5 in image walk, walk2 and pwalk all invisibly return .x the first argument. This makes them suitable for use in the middle of pipelines. "],["imap.html", "imap()", " imap() imap() is like map2()except that .y is derived from names(.x) if named or seq_along(.x) if not These two produce the same result imap_chr(.x = mtcars, .f = ~ paste(.y, &quot;has a mean of&quot;, round(mean(.x), 1))) %&gt;% head() #&gt; mpg cyl #&gt; &quot;mpg has a mean of 20.1&quot; &quot;cyl has a mean of 6.2&quot; #&gt; disp hp #&gt; &quot;disp has a mean of 230.7&quot; &quot;hp has a mean of 146.7&quot; #&gt; drat wt #&gt; &quot;drat has a mean of 3.6&quot; &quot;wt has a mean of 3.2&quot; "],["pmap.html", "pmap()", " pmap() you can pass a named list or dataframe as arguments to a function for example runif() has the parameters n, min and max params &lt;- tibble::tribble( ~ n, ~ min, ~ max, 1L, 1, 10, 2L, 10, 100, 3L, 100, 1000 ) pmap(params, runif) #&gt; [[1]] #&gt; [1] 9.417698 #&gt; #&gt; [[2]] #&gt; [1] 37.11060 15.46485 #&gt; #&gt; [[3]] #&gt; [1] 952.9542 748.5366 228.0649 could also be list( n = 1:3, min = 10 ^ (0:2), max = 10 ^ (1:3) ) %&gt;% pmap(runif) #&gt; [[1]] #&gt; [1] 5.943562 #&gt; #&gt; [[2]] #&gt; [1] 95.86821 62.69350 #&gt; #&gt; [[3]] #&gt; [1] 464.0593 683.1041 387.8386 "],["reduce-family.html", "9.5 reduce() family", " 9.5 reduce() family The reduce() function is a powerful functional that allows you to abstract away from a sequence of functions that are applied in a fixed direction. reduce takes a vector as its first argument, a function as its second argument, and an optional .init argument, it will then apply this function repeatedly to a list until there is only a single element left. Let me really quickly demonstrate reduce() in action. Say you wanted to add up the numbers 1 through 5, but only using the plus operator +. You could do something like this 1 + 2 + 3 + 4 + 5 #&gt; [1] 15 Which is the same thing as this: set.seed(1234) reduce(1:5, `+`) #&gt; [1] 15 And if you want the start value to be something that‚Äôs not the first argument of the vector, pass that to the .init argument: identical( 0.5 + 1 + 2 + 3 + 4 + 5, reduce(1:5, `+`, .init = 0.5) ) #&gt; [1] TRUE "],["ggplot2-example-with-reduce.html", "ggplot2 Example with reduce", " ggplot2 Example with reduce ggplot(mtcars, aes(hp, mpg)) + geom_point(size = 8, alpha = .5) + geom_point(size = 4, alpha = .5) + geom_point(size = 2, alpha = .5) Let us use the reduce function reduce( c(8, 4, 2), ~ .x + geom_point(size = .y, alpha = .5), .init = ggplot(mtcars, aes(hp, mpg)) ) df &lt;- list(age=tibble(name=&#39;john&#39;,age=30), sex=tibble(name=c(&#39;john&#39;,&#39;mary&#39;),sex=c(&#39;M&#39;,&#39;F&#39;), trt=tibble(name=&#39;Mary&#39;,treatment=&#39;A&#39;))) df |&gt; reduce(.f = full_join) #&gt; Joining, by = &quot;name&quot; #&gt; # A tibble: 2 √ó 4 #&gt; name age sex trt$name $treatment #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 john 30 M Mary A #&gt; 2 mary NA F Mary A reduce(.x = df,.f = full_join) #&gt; Joining, by = &quot;name&quot; #&gt; # A tibble: 2 √ó 4 #&gt; name age sex trt$name $treatment #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 john 30 M Mary A #&gt; 2 mary NA F Mary A to see all intermediate steps, use accumulate() set.seed(1234) accumulate(1:5, `+`) #&gt; [1] 1 3 6 10 15 "],["not-covered-map_df-variants.html", "Not covered: map_df*() variants", " Not covered: map_df*() variants map_dfr() = row bind the results map_dfc() = column bind the results col_stats &lt;- function(n) { head(mtcars, n) %&gt;% summarise_all(mean) %&gt;% mutate_all(floor) %&gt;% mutate(n = paste(&quot;N =&quot;, n)) } map((1:2) * 10, col_stats) #&gt; [[1]] #&gt; mpg cyl disp hp drat wt qsec vs am gear carb n #&gt; 1 20 5 208 122 3 3 18 0 0 3 2 N = 10 #&gt; #&gt; [[2]] #&gt; mpg cyl disp hp drat wt qsec vs am gear carb n #&gt; 1 20 6 233 136 3 3 18 0 0 3 2 N = 20 map_dfr((1:2) * 10, col_stats) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb n #&gt; 1 20 5 208 122 3 3 18 0 0 3 2 N = 10 #&gt; 2 20 6 233 136 3 3 18 0 0 3 2 N = 20 "],["not-covered-pluck.html", "Not covered: pluck()", " Not covered: pluck() pluck() will pull a single element from a list my_list &lt;- list( 1:3, 10 + (1:5), 20 + (1:10) ) pluck(my_list, 1) #&gt; [1] 1 2 3 map(my_list, pluck, 1) #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] 11 #&gt; #&gt; [[3]] #&gt; [1] 21 map_dbl(my_list, pluck, 1) #&gt; [1] 1 11 21 "],["not-covered-flatten.html", "Not covered: flatten()", " Not covered: flatten() flatten() will turn a list of lists into a simpler vector my_list &lt;- list( a = 1:3, b = list(1:3) ) map_if(my_list, is.list, pluck) #&gt; $a #&gt; [1] 1 2 3 #&gt; #&gt; $b #&gt; $b[[1]] #&gt; [1] 1 2 3 map_if(my_list, is.list, flatten_int) #&gt; $a #&gt; [1] 1 2 3 #&gt; #&gt; $b #&gt; [1] 1 2 3 map_if(my_list, is.list, flatten_int) %&gt;% flatten_int() #&gt; [1] 1 2 3 1 2 3 "],["dealing-with-failures.html", "Dealing with Failures", " Dealing with Failures "],["safely.html", "Safely", " Safely safely is an adverb, it takes a function (a verb) and returns a modified version. In this case, the modified function will never throw an error. Instead it always returns a list with two elements. Result is the original result. If there is an error this will be NULL Error is an error object. If the operation was successful this will be NULL. A &lt;- list(1,10,&quot;a&quot;) map(.x = A,.f = safely(log)) #&gt; [[1]] #&gt; [[1]]$result #&gt; [1] 0 #&gt; #&gt; [[1]]$error #&gt; NULL #&gt; #&gt; #&gt; [[2]] #&gt; [[2]]$result #&gt; [1] 2.302585 #&gt; #&gt; [[2]]$error #&gt; NULL #&gt; #&gt; #&gt; [[3]] #&gt; [[3]]$result #&gt; NULL #&gt; #&gt; [[3]]$error #&gt; &lt;simpleError in .Primitive(&quot;log&quot;)(x, base): non-numeric argument to mathematical function&gt; "],["possibly.html", "Possibly", " Possibly Possibly always succeeds. It is simpler than safely, because you can give it a default value to return when there is an error. A &lt;- list(1,10,&quot;a&quot;) map_dbl(.x =A,.f = possibly(log,otherwise = NA_real_) ) #&gt; [1] 0.000000 2.302585 NA "],["meeting-videos-8.html", "9.6 Meeting Videos", " 9.6 Meeting Videos 9.6.1 Cohort 1 9.6.2 Cohort 2 9.6.3 Cohort 3 9.6.4 Cohort 4 9.6.5 Cohort 5 9.6.6 Cohort 6 Meeting chat log LOG "],["function-factories.html", "Chapter 10 Function factories", " Chapter 10 Function factories Learning objectives: Understand what a function factory is Recognise how function factories work Learn about non-obvious combination of function features Generate a family of functions from data "],["introduction-4.html", "10.1 Introduction", " 10.1 Introduction In this chapter we‚Äôll talk about function factories. A type of functions that make other functions. We‚Äôll tackle some challegenges in understanding how to make a workflow of functions. "],["what-is-a-function-factory.html", "10.2 What is a function factory?", " 10.2 What is a function factory? A function factory is a function that makes functions Factory made function are manufactured functions. Figure 10.1: Function factory | Credits: epsis.com "],["how-does-a-function-factory-work.html", "10.3 How does a function factory work?", " 10.3 How does a function factory work? Figure 10.2: How does it work? | Credits: kakaakigas.com/how-it-works/ power1 &lt;- function(exp) { function(x) { x ^ exp } } square &lt;- power1(2) cube &lt;- power1(3) power1() is the function factory and square() and cube() are manufactured functions. What we know already: Function Features first-class functions name &lt;- function(variables) { } function environment fn_env() y &lt;- 1 f &lt;- function(x) x + y rlang::fn_env(f) #&gt; &lt;environment: R_GlobalEnv&gt; function execution environment h &lt;- function(x) { # 1. a &lt;- 2 # 2. assingned value in the environment x + a } y &lt;- h(1) # 3. A function factory is defined as a functional programming tools, as well as functionals, and function operators. An application would be to tackle the understanding of: Box-Cox transformation maximum likelihood problems bootstrap resamples 10.3.1 Factory fundamentals Environments Force calculation Super assignments Cleaning up library(rlang) #&gt; #&gt; Attaching package: &#39;rlang&#39; #&gt; The following object is masked _by_ &#39;.GlobalEnv&#39;: #&gt; #&gt; warn #&gt; The following objects are masked from &#39;package:purrr&#39;: #&gt; #&gt; %@%, as_function, flatten, flatten_chr, flatten_dbl, flatten_int, #&gt; flatten_lgl, flatten_raw, invoke, splice library(ggplot2) library(scales) #&gt; #&gt; Attaching package: &#39;scales&#39; #&gt; The following object is masked from &#39;package:purrr&#39;: #&gt; #&gt; discard #&gt; The following object is masked from &#39;package:readr&#39;: #&gt; #&gt; col_factor Looking at manufactored functions, in our example the square() function, and imagine to do not know anything about it. The environment can be investigated with env_print() function. Two different enviroments can be found, with the same parent. rlang::env_print(square) #&gt; &lt;environment: 0x55e81ef15d20&gt; #&gt; Parent: &lt;environment: global&gt; #&gt; Bindings: #&gt; ‚Ä¢ exp: &lt;lazy&gt; To know more about it, exp is visible as the engine of the function, the computed value (square &lt;- power1(2)) can be retrieved like this: fn_env(square)$exp #&gt; [1] 2 To make sure every argument is evaluated, whenever x is assigned to a different value. force() power1 &lt;- function(exp) { function(x) { x ^ exp } } square &lt;- power1(x) x &lt;- 2 square(2) #&gt; [1] 4 Assign a value to the variable x, while it goes in the environment, see what‚Äôs happen to our function: x &lt;- 3 square(2) #&gt; [1] 4 This is not necessarely wrong, but what if we‚Äôd like to set a variable x which can assume other values in the environment? power2 &lt;- function(exp) { force(exp) function(x) { x ^ exp } } x &lt;- 2 square &lt;- power2(x) square(2) #&gt; [1] 4 Look what‚Äôs happen now: x &lt;- 3 square(2) #&gt; [1] 4 Even if we assigned a new value to x and it is stored in the environment, our function doesn‚Äôt take consideration of it and keep doing its calculation based on the first variable assignment. The super assignment operator &lt;&lt;- Another way is to set the function to mantain the state, in a way that each invocation will be completely independent, and a new environment is created, because considered as a fresh start (6.4.3). new_counter &lt;- function() { i &lt;- 0 # first assignment inside the function (fresh start) function() { i &lt;&lt;- i + 1 # second assignment (super assignment) i } } counter_one &lt;- new_counter() counter_two &lt;- new_counter() counter_one() #&gt; [1] 1 counter_one() #&gt; [1] 2 counter_two() #&gt; [1] 1 ‚ÄúAs soon as your function starts managing the state of multiple variables, it‚Äôs better to switch to R6‚Äù Cleaning up using rm() inside a function: f1 &lt;- function(n) { x &lt;- runif(n) m &lt;- mean(x) function() m } g1 &lt;- f1(1e6) lobstr::obj_size(g1) #&gt; 8.01 MB #&gt; 8,013,104 B f2 &lt;- function(n) { x &lt;- runif(n) m &lt;- mean(x) rm(x) function() m } g2 &lt;- f2(1e6) lobstr::obj_size(g2) #&gt; 13.26 kB #&gt; 12,944 B 10.3.2 Example of: Graphical factories Graphical factories useful function factories, such as: Labelling with: formatter functions y &lt;- c(12345, 123456, 1234567) comma_format()(y) #&gt; [1] &quot;12,345&quot; &quot;123,456&quot; &quot;1,234,567&quot; number_format(scale = 1e-3, suffix = &quot; K&quot;)(y) #&gt; [1] &quot;12 K&quot; &quot;123 K&quot; &quot;1 235 K&quot; They are more commonly used inside a ggplot: a_ggplot_object + scale_y_continuous( labels = comma_format() ) Using binwidth in facet histograms binwidth_bins binwidth_bins &lt;- function(n) { force(n) function(x) { (max(x) - min(x)) / n } } Or use a concatenation of this typr of detecting number of bins functions: - nclass.Sturges() - nclass.scott() - nclass.FD() base_bins &lt;- function(type) { fun &lt;- switch(type, Sturges = nclass.Sturges, scott = nclass.scott, FD = nclass.FD, stop(&quot;Unknown type&quot;, call. = FALSE) ) function(x) { (max(x) - min(x)) / fun(x) } } Internals: ggplot2:::plot_dev() "],["non-obvious-combinations.html", "10.4 Non-obvious combinations", " 10.4 Non-obvious combinations The Box-Cox transformation. Bootstrap resampling. Maximum likelihood estimation. 10.4.1 Statistical factories The Box-Cox transformation towards normality: boxcox1 &lt;- function(x, lambda) { stopifnot(length(lambda) == 1) if (lambda == 0) { log(x) } else { (x ^ lambda - 1) / lambda } } boxcox2 &lt;- function(lambda) { if (lambda == 0) { function(x) log(x) } else { function(x) (x ^ lambda - 1) / lambda } } stat_boxcox &lt;- function(lambda) { stat_function(aes(colour = lambda), fun = boxcox2(lambda), size = 1) } plot1 &lt;- ggplot(data.frame(x = c(0, 5)), aes(x)) + lapply(c(0.5, 1, 1.5), stat_boxcox) + scale_colour_viridis_c(limits = c(0, 1.5)) # visually, log() does seem to make sense as the transformation # for lambda = 0; as values get smaller and smaller, the function # gets close and closer to a log transformation plot2 &lt;- ggplot(data.frame(x = c(0.01, 1)), aes(x)) + lapply(c(0.5, 0.25, 0.1, 0), stat_boxcox) + scale_colour_viridis_c(limits = c(0, 1.5)) library(patchwork) plot1+plot2 Bootstrap generators boot_permute &lt;- function(df, var) { n &lt;- nrow(df) force(var) function() { col &lt;- df[[var]] col[sample(n, replace = TRUE)] } } boot_mtcars1 &lt;- boot_permute(mtcars, &quot;mpg&quot;) head(boot_mtcars1()) #&gt; [1] 30.4 10.4 22.8 30.4 15.5 10.4 #&gt; [1] 16.4 22.8 22.8 22.8 16.4 19.2 head(boot_mtcars1()) #&gt; [1] 15.8 15.2 21.0 17.8 15.5 13.3 #&gt; [1] 17.8 18.7 30.4 30.4 16.4 21.0 boot_model &lt;- function(df, formula) { mod &lt;- lm(formula, data = df) fitted &lt;- unname(fitted(mod)) resid &lt;- unname(resid(mod)) rm(mod) function() { fitted + sample(resid) } } boot_mtcars2 &lt;- boot_model(mtcars, mpg ~ wt) head(boot_mtcars2()) #&gt; [1] 24.48367 21.00000 31.75866 26.52463 18.70000 15.82067 #&gt; [1] 25.0 24.0 21.7 19.2 24.9 16.0 head(boot_mtcars2()) #&gt; [1] 21.00000 23.66597 23.00293 22.20594 16.11920 16.70730 #&gt; [1] 27.4 21.0 20.3 19.4 16.3 21.3 Maximum likelihood estimation \\[P(\\lambda,x)=\\prod_{i=1}^{n}\\frac{\\lambda^{x_i}e^{-\\lambda}}{x_i!}\\] lprob_poisson &lt;- function(lambda, x) { n &lt;- length(x) (log(lambda) * sum(x)) - (n * lambda) - sum(lfactorial(x)) } x1 &lt;- c(41, 30, 31, 38, 29, 24, 30, 29, 31, 38) lprob_poisson(10, x1) #&gt; [1] -183.6405 #&gt; [1] -184 lprob_poisson(20, x1) #&gt; [1] -61.14028 #&gt; [1] -61.1 lprob_poisson(30, x1) #&gt; [1] -30.98598 #&gt; [1] -31 ll_poisson1 &lt;- function(x) { n &lt;- length(x) function(lambda) { log(lambda) * sum(x) - n * lambda - sum(lfactorial(x)) } } ll_poisson2 &lt;- function(x) { n &lt;- length(x) sum_x &lt;- sum(x) c &lt;- sum(lfactorial(x)) function(lambda) { log(lambda) * sum_x - n * lambda - c } } ll1 &lt;- ll_poisson2(x1) ll1(10) #&gt; [1] -183.6405 #&gt; [1] -184 ll1(20) #&gt; [1] -61.14028 #&gt; [1] -61.1 ll1(30) #&gt; [1] -30.98598 #&gt; [1] -31 optimise(ll1, c(0, 100), maximum = TRUE) #&gt; $maximum #&gt; [1] 32.09999 #&gt; #&gt; $objective #&gt; [1] -30.26755 #&gt; $maximum #&gt; [1] 32.1 #&gt; #&gt; $objective #&gt; [1] -30.3 optimise(lprob_poisson, c(0, 100), x = x1, maximum = TRUE) #&gt; $maximum #&gt; [1] 32.09999 #&gt; #&gt; $objective #&gt; [1] -30.26755 #&gt; $maximum #&gt; [1] 32.1 #&gt; #&gt; $objective #&gt; [1] -30.3 "],["function-factory-applications.html", "10.5 Function factory applications", " 10.5 Function factory applications Combine functionals and function factories to turn data into many functions. 10.5.1 Function factories + functionals names &lt;- list( square = 2, cube = 3, root = 1/2, cuberoot = 1/3, reciprocal = -1 ) funs &lt;- purrr::map(names, power1) funs$root(64) #&gt; [1] 8 #&gt; [1] 8 funs$root #&gt; function(x) { #&gt; x ^ exp #&gt; } #&gt; &lt;bytecode: 0x55e81e5cc200&gt; #&gt; &lt;environment: 0x55e81e817fa8&gt; #&gt; function(x) { #&gt; x ^ exp #&gt; } #&gt; &lt;bytecode: 0x7fe85512a410&gt; #&gt; &lt;environment: 0x7fe85b21f190&gt; with(funs, root(100)) #&gt; [1] 10 #&gt; [1] 10 attach(funs) #&gt; The following objects are masked _by_ .GlobalEnv: #&gt; #&gt; cube, square #&gt; The following objects are masked _by_ .GlobalEnv: #&gt; #&gt; cube, square root(100) #&gt; [1] 10 #&gt; [1] 10 detach(funs) rlang::env_bind(globalenv(), !!!funs) root(100) #&gt; [1] 10 #&gt; [1] 10 rlang::env_unbind(globalenv(), names(funs)) "],["meeting-videos-9.html", "10.6 Meeting Videos", " 10.6 Meeting Videos 10.6.1 Cohort 1 10.6.2 Cohort 2 10.6.3 Cohort 3 10.6.4 Cohort 4 10.6.5 Cohort 5 10.6.6 Cohort 6 Meeting chat log LOG "],["function-operators.html", "Chapter 11 Function operators", " Chapter 11 Function operators Learning objectives: define of function operator find existing function operators how to make your own function operator "],["introduction-5.html", "11.1 Introduction", " 11.1 Introduction In this chapter we‚Äôll learn how to use function operator as a case of function factories. And we‚Äôll see a case study about how to download many web pages using a function operator. "],["definition-and-practical-examples.html", "11.2 Definition and practical examples", " 11.2 Definition and practical examples Figure 11.1: Credits: 2001-2003 Michael P.Frank (https://slideplayer.com/slide/17666226/) A function operator is a function that takes one (or more) functions as input and returns a function as output Function operators are closely related to function factories, infact are a particular case which uses a function as an input. These are the two libraries to use for finding function operator examples: library(purrr) library(memoise) What do they do? Caching errors: purrr::safely() Caching computations: this function is an example of dynamic programming memoise::memoise() 11.2.1 Other exsitsting function operators Figure 11.2: Credits: www.nextptr.com purrr comes with three other function operators in a similar vein: possibly(): returns a default value when there‚Äôs an error. It provides no way to tell if an error occured or not, so it‚Äôs best reserved for cases when there‚Äôs some obvious sentinel value (like NA). quietly(): turns output, messages, and warning side-effects into output, message, and warning components of the output. auto_browser(): automatically executes browser() inside the function when there‚Äôs an error. "],["case-study-make-your-own-function-operator.html", "11.3 Case study: make your own function operator", " 11.3 Case study: make your own function operator urls &lt;- c( &quot;adv-r&quot; = &quot;https://adv-r.hadley.nz&quot;, &quot;r4ds&quot; = &quot;http://r4ds.had.co.nz/&quot; # and many many more ) path &lt;- paste(tempdir(), names(urls), &quot;.html&quot;) walk2(urls, path, download.file, quiet = TRUE) Here we make a function operator that add a little delay in reading each page: delay_by &lt;- function(f, amount) { force(f) force(amount) function(...) { Sys.sleep(amount) f(...) } } system.time(runif(100)) #&gt; user system elapsed #&gt; 0 0 0 #&gt; user system elapsed #&gt; 0 0 0 system.time(delay_by(runif, 0.1)(100)) #&gt; user system elapsed #&gt; 0.001 0.000 0.100 #&gt; user system elapsed #&gt; 0.00 0.00 0.13 walk2(urls, path, delay_by(download.file, 0.1), quiet = TRUE) "],["meeting-videos-10.html", "11.4 Meeting Videos", " 11.4 Meeting Videos 11.4.1 Cohort 1 11.4.2 Cohort 2 11.4.3 Cohort 3 11.4.4 Cohort 4 11.4.5 Cohort 5 11.4.6 Cohort 6 Meeting chat log LOG "],["base-types.html", "Chapter 12 Base types", " Chapter 12 Base types Learning objectives: Understand what OOP means‚Äìat the very least for R Know how to discern an object‚Äôs nature‚Äìbase or OO‚Äìand type "],["why-oop-is-hard-in-r.html", "12.1 Why OOP is hard in R", " 12.1 Why OOP is hard in R Multiple OOP systems exist: S3, R6, S4, and (now/soon) R7. Multiple preferences: some users prefer one system; others, another. R‚Äôs OOP systems are different enough that prior OOP experience may not transfer well. "],["what-is-oop-in-general.html", "12.2 What is OOP in general?", " 12.2 What is OOP in general? 12.2.1 Two big ideas Polymorphism. Function has a single interface (outside), but contains (inside) several class-specific implementations. # imagine a function with object x as an argument # from the outside, users interact with the same function # but inside the function, there are provisions to deal with objects of different classes some_function &lt;- function(x) { if is.numeric(x) { # implementation for numeric x } else if is.character(x) { # implementation for character x } ... } Encapsulation. Function ‚Äúencapsulates‚Äù‚Äìthat is, encloses in an inviolate capsule‚Äìboth data and how it acts on data. Think of a REST API: a client interacts with with an API only through a set of discrete endpoints (i.e., things to get or set), but the server does not otherwise give access to its internal workings or state. Like with an API, this creates a separation of concerns: OOP functions take inputs and yield results; users only consume those results. 12.2.2 A few practical ideas 12.2.2.1 Objects have class Class defines: Method (i.e., what can be done with object) Fields (i.e., data that defines an instance of the class) Objects are an instance of a class 12.2.2.2 Class is inherited Class is defined: By an object‚Äôs class (e.g., ordered factor) By the parent of the object‚Äôs class (e.g., factor) Inheritance matters for method dispatch If a method is defined for an object‚Äôs class, use that method If an object doesn‚Äôt have a method, use the method of the parent class The process of finding a method, is called dispatch "],["what-about-oop-in-r.html", "12.3 What about OOP in R?", " 12.3 What about OOP in R? 12.3.1 Two main paradigms 1. Encapsulated OOP Objects ‚Äúencapsulate‚Äù Methods (i.e., what can be done) Fields (i.e., data on which things are done) Calls communicate this encapsulation, since form follows function Form: object.method(arg1, arg2) Function: for object, apply method for object‚Äôs class with arguments arg1 and arg2 2. Functional OOP Methods belong to ‚Äúgeneric‚Äù functions From the outside, look like regular functions: generic(object, arg2, arg3) From the inside, components are also functions 12.3.2 Overview of the systems In base R: S3 Paradigm: functional OOP Noteworthy: R‚Äôs first OOP system Use case: low-cost solution for common problems Downsides: no guarantees S4 Paradigm: functional OOP Noteworthy: rewrite of S3 Use case: ‚Äúmore guarantees and greater encapsulation‚Äù than S3 Downsides: higher setup cost than S3 RC Paradigm: encapsulated OOP Noteworthy: special type of S4 object is mutable‚Äìin other words, that can be modified in place (instead of R‚Äôs usual copy-on-modify behavior) Use cases: problems that are hard to tackle with functional OOP (in S3 and S4) Downsides: harder to reason about (because of modify-in-place logic) In packages: R6 Paradigm: encapsulated OOP Noteworthy: resolves issues with RC R7 Paradigm: functional OOP Noteworthy: best parts of S3 and S4 ease of S3 power of S4 See more in rstudio::conf(2022) talk R.oo Paradigm: hybrid functional and encapsulated (?) proto Paradigm: prototype OOP Noteworthy: OOP style used in ggplot2 "],["how-can-you-tell-if-an-object-is-base-or-oop.html", "12.4 How can you tell if an object is base or OOP?", " 12.4 How can you tell if an object is base or OOP? 12.4.1 Functions Two functions: base::is.object(), which yields TRUE/FALSE about whether is OOP object sloop::otype(), which says what type of object type: \"base\", \"S3\", etc. An few examples: # Example 1: a base object is.object(1:10) #&gt; [1] FALSE sloop::otype(1:10) #&gt; [1] &quot;base&quot; # Example 2: an OO object is.object(mtcars) #&gt; [1] TRUE sloop::otype(mtcars) #&gt; [1] &quot;S3&quot; 12.4.2 Class OO objects have a ‚Äúclass‚Äù attribute: # base object has no class attr(1:10, &quot;class&quot;) #&gt; NULL # OO object has one or more class attr(mtcars, &quot;class&quot;) #&gt; [1] &quot;data.frame&quot; "],["what-about-types.html", "12.5 What about types?", " 12.5 What about types? Only OO objects have a ‚Äúclass‚Äù attribute, but every object‚Äìwhether base or OO‚Äìhas class 12.5.1 Vectors typeof(NULL) #&gt; [1] &quot;NULL&quot; typeof(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) #&gt; [1] &quot;character&quot; typeof(1L) #&gt; [1] &quot;integer&quot; typeof(1i) #&gt; [1] &quot;complex&quot; 12.5.2 Functions # &quot;normal&quot; function my_fun &lt;- function(x) { x + 1 } typeof(my_fun) #&gt; [1] &quot;closure&quot; # internal function typeof(`[`) #&gt; [1] &quot;special&quot; # primitive function typeof(sum) #&gt; [1] &quot;builtin&quot; 12.5.3 Environments typeof(globalenv()) #&gt; [1] &quot;environment&quot; 12.5.4 S4 mle_obj &lt;- stats4::mle(function(x = 1) (x - 2) ^ 2) typeof(mle_obj) #&gt; [1] &quot;S4&quot; 12.5.5 Language components typeof(quote(a)) #&gt; [1] &quot;symbol&quot; typeof(quote(a + 1)) #&gt; [1] &quot;language&quot; typeof(formals(my_fun)) #&gt; [1] &quot;pairlist&quot; "],["be-careful-about-the-numeric-type.html", "12.6 Be careful about the numeric type", " 12.6 Be careful about the numeric type Often ‚Äúnumeric‚Äù is treated as synonymous for double: # create a double and integeger objects one &lt;- 1 oneL &lt;- 1L typeof(one) #&gt; [1] &quot;double&quot; typeof(oneL) #&gt; [1] &quot;integer&quot; # check their type after as.numeric() one |&gt; as.numeric() |&gt; typeof() #&gt; [1] &quot;double&quot; oneL |&gt; as.numeric() |&gt; typeof() #&gt; [1] &quot;double&quot; In S3 and S4, ‚Äúnumeric‚Äù is taken as either integer or double, when choosing methods: sloop::s3_class(1) #&gt; [1] &quot;double&quot; &quot;numeric&quot; sloop::s3_class(1L) #&gt; [1] &quot;integer&quot; &quot;numeric&quot; is.numeric() tests whether an object behaves like a number typeof(factor(&quot;x&quot;)) #&gt; [1] &quot;integer&quot; is.numeric(factor(&quot;x&quot;)) #&gt; [1] FALSE But Advanced R consistently uses numeric to mean integer or double type. "],["meeting-videos-11.html", "12.7 Meeting Videos", " 12.7 Meeting Videos 12.7.1 Cohort 1 12.7.2 Cohort 2 12.7.3 Cohort 3 12.7.4 Cohort 4 12.7.5 Cohort 5 12.7.6 Cohort 6 Meeting chat log LOG "],["s3.html", "Chapter 13 S3 ", " Chapter 13 S3 "],["basics.html", "13.1 Basics", " 13.1 Basics Has class Uses a generic function to decide on method method = implementation for a specific class dispatch = process of searching for right method "],["classes.html", "13.2 Classes", " 13.2 Classes 13.2.1 Theory What is class? No formal definition in S3 Simply set class attribute How to set class? At time of object creation After object creation # at time of object creation x &lt;- structure(list(), class = &quot;my_class&quot;) # after object creation x &lt;- list() class(x) &lt;- &quot;my_class&quot; Some advice on style: Rules: Can be any string Advice: Consider using/including package name to avoid collision with name of another class (e.g., blob, which defines a single class; haven has labelled and haven_labelled) Convention: letters and _; avoid . since it might be confused as separator between generic and class name 13.2.2 Practice How to compose a class in practice? Constructor, which helps the developer create new object of target class. Provide always. Validator, which checks that values in constructor are valid. May not be necessary for simple classes. Helper, which helps users create new objects of target class. May be relevant only for user-facing classes. 13.2.3 Constructors Help developers construct an object of the target class: new_difftime &lt;- function(x = double(), units = &quot;secs&quot;) { # check inputs # issue generic system error if unexpected type or value stopifnot(is.double(x)) units &lt;- match.arg(units, c(&quot;secs&quot;, &quot;mins&quot;, &quot;hours&quot;, &quot;days&quot;, &quot;weeks&quot;)) # construct instance of target class structure(x, class = &quot;difftime&quot;, units = units ) } 13.2.4 Validators Contrast a constructor, aimed at quickly creating instances of a class, which only checks type of inputs ‚Ä¶ new_factor &lt;- function(x = integer(), levels = character()) { stopifnot(is.integer(x)) stopifnot(is.character(levels)) structure( x, levels = levels, class = &quot;factor&quot; ) } # error messages are for system default and developer-facing new_factor(1:5, &quot;a&quot;) #&gt; Error in as.character.factor(x): malformed factor ‚Ä¶ with a validator, aimed at emitting errors if inputs pose problems, which makes more expensive checks validate_factor &lt;- function(x) { values &lt;- unclass(x) levels &lt;- attr(x, &quot;levels&quot;) if (!all(!is.na(values) &amp; values &gt; 0)) { stop( &quot;All `x` values must be non-missing and greater than zero&quot;, call. = FALSE ) } if (length(levels) &lt; max(values)) { stop( &quot;There must be at least as many `levels` as possible values in `x`&quot;, call. = FALSE ) } x } # error messages are informative and user-facing validate_factor(new_factor(1:5, &quot;a&quot;)) #&gt; Error: There must be at least as many `levels` as possible values in `x` 13.2.5 Helpers Some desired virtues: Have the same name as the class Call the constructor and validator, if the latter exists. Issue error informative, user-facing error messages Adopt thoughtful/useful defaults or type conversion "],["generics-and-methods.html", "13.3 Generics and methods", " 13.3 Generics and methods 13.3.1 Generic functions Consist of a call to UseMethod() Pass arguments from the generic to the dispatched method ‚Äúauto-magically‚Äù my_new_generic &lt;- function(x) { UseMethod(&quot;my_new_generic&quot;) } 13.3.2 Method dispatch UseMethod() creates a vector of method names Dispatch Examines all methods in the vector Selects a method x &lt;- Sys.Date() sloop::s3_dispatch(print(x)) #&gt; =&gt; print.Date #&gt; * print.default 13.3.3 Finding methods While sloop::s3_dispatch() gives the specific method selected for a specific call, on can see the methods defined: For a generic sloop::s3_methods_generic(&quot;mean&quot;) #&gt; # A tibble: 8 √ó 4 #&gt; generic class visible source #&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; #&gt; 1 mean Date TRUE base #&gt; 2 mean default TRUE base #&gt; 3 mean difftime TRUE base #&gt; 4 mean integer64 FALSE registered S3method #&gt; 5 mean POSIXct TRUE base #&gt; 6 mean POSIXlt TRUE base #&gt; 7 mean quosure FALSE registered S3method #&gt; 8 mean vctrs_vctr FALSE registered S3method For a class sloop::s3_methods_class(&quot;ordered&quot;) #&gt; # A tibble: 6 √ó 4 #&gt; generic class visible source #&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; #&gt; 1 as.data.frame ordered TRUE base #&gt; 2 Ops ordered TRUE base #&gt; 3 relevel ordered FALSE registered S3method #&gt; 4 scale_type ordered FALSE registered S3method #&gt; 5 Summary ordered TRUE base #&gt; 6 type_sum ordered FALSE registered S3method 13.3.4 Creating methods Two rules: Only write a method if you own the generic. Otherwise, bad manners. Method must have same arguments as its generic‚Äìwith one important exception: ... 13.3.5 Examples caught in the wild haven::zap_label, which removes column labels dplyr::mutate tidyr::pivot_longer "],["inheritance.html", "13.4 Inheritance", " 13.4 Inheritance Three ideas: Class is a vector of classes class(ordered(&quot;x&quot;)) #&gt; [1] &quot;ordered&quot; &quot;factor&quot; class(Sys.time()) #&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot; Dispatch moves through class vector until it finds a defined method sloop::s3_dispatch(print(ordered(&quot;x&quot;))) #&gt; print.ordered #&gt; =&gt; print.factor #&gt; * print.default Method can delegate to another method via NextMethod(), which is indicated by &lt;- as below: sloop::s3_dispatch(ordered(&quot;x&quot;)[1]) #&gt; [.ordered #&gt; =&gt; [.factor #&gt; [.default #&gt; -&gt; [ (internal) 13.4.1 NextMethod() Consider secret class that masks each character of the input with x in output new_secret &lt;- function(x = double()) { stopifnot(is.double(x)) structure(x, class = &quot;secret&quot;) } print.secret &lt;- function(x, ...) { print(strrep(&quot;x&quot;, nchar(x))) invisible(x) } x &lt;- new_secret(c(15, 1, 456)) x #&gt; [1] &quot;xx&quot; &quot;x&quot; &quot;xxx&quot; Notice that the [ method is problematic in that it does not preserve the secret class sloop::s3_dispatch(x[1]) #&gt; [.secret #&gt; [.default #&gt; =&gt; [ (internal) Fix this with a [.secret method: `[.secret` &lt;- function(x, i) { # first, dispatch to `[` # then, coerce subset value to `secret` class new_secret(NextMethod()) } Notice that [.secret is selected for dispatch, but that the method delegates to the internal [ sloop::s3_dispatch(x[1]) #&gt; =&gt; [.secret #&gt; [.default #&gt; -&gt; [ (internal) 13.4.2 Allowing subclassing Continue the example above to have a supersecret subclass that hides even the number of characters in the input (e.g., 123 -&gt; xxxxx, 12345678 -&gt; xxxxx, 1 -&gt; xxxxx). To allow for this subclass, the constructor function needs to include two additional arguments: ... for passing an arbitrary set of arguments to different subclasses class for defining the subclass new_secret &lt;- function(x, ..., class = character()) { stopifnot(is.double(x)) structure( x, ..., class = c(class, &quot;secret&quot;) ) } To create the subclass, simply invoke the parent class constructor inside of the subclass constructor: new_supersecret &lt;- function(x) { new_secret(x, class = &quot;supersecret&quot;) } print.supersecret &lt;- function(x, ...) { print(rep(&quot;xxxxx&quot;, length(x))) invisible(x) } But this means the subclass inherits all parent methods and needs to overwrite all parent methods with subclass methods that return the sublclass rather than the parent class. There‚Äôs no easy solution to this problem in base R. There is a solution in the vectors package: vctrs::vec_restore() "],["meeting-videos-12.html", "13.5 Meeting Videos", " 13.5 Meeting Videos 13.5.1 Cohort 1 13.5.2 Cohort 2 13.5.3 Cohort 3 13.5.4 Cohort 4 13.5.5 Cohort 5 13.5.6 Cohort 6 Meeting chat log LOG "],["r6.html", "Chapter 14 R6", " Chapter 14 R6 Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-2.html", "14.1 SLIDE 1", " 14.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-13.html", "14.2 Meeting Videos", " 14.2 Meeting Videos 14.2.1 Cohort 1 14.2.2 Cohort 2 14.2.3 Cohort 3 14.2.4 Cohort 4 14.2.5 Cohort 5 14.2.6 Cohort 6 Meeting chat log LOG "],["s4-1.html", "Chapter 15 S4", " Chapter 15 S4 Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-3.html", "15.1 SLIDE 1", " 15.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-14.html", "15.2 Meeting Videos", " 15.2 Meeting Videos 15.2.1 Cohort 1 15.2.2 Cohort 2 15.2.3 Cohort 3 15.2.4 Cohort 4 15.2.5 Cohort 5 15.2.6 Cohort 6 Meeting chat log LOG "],["trade-offs.html", "Chapter 16 Trade-offs", " Chapter 16 Trade-offs Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-4.html", "16.1 SLIDE 1", " 16.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-15.html", "16.2 Meeting Videos", " 16.2 Meeting Videos 16.2.1 Cohort 1 16.2.2 Cohort 2 16.2.3 Cohort 3 16.2.4 Cohort 4 16.2.5 Cohort 5 16.2.6 Cohort 6 Meeting chat log LOG "],["big-picture.html", "Chapter 17 Big picture", " Chapter 17 Big picture Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-5.html", "17.1 SLIDE 1", " 17.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-16.html", "17.2 Meeting Videos", " 17.2 Meeting Videos 17.2.1 Cohort 1 17.2.2 Cohort 2 17.2.3 Cohort 3 17.2.4 Cohort 4 17.2.5 Cohort 5 17.2.6 Cohort 6 Meeting chat log LOG "],["expressions.html", "Chapter 18 Expressions", " Chapter 18 Expressions Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-6.html", "18.1 SLIDE 1", " 18.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-17.html", "18.2 Meeting Videos", " 18.2 Meeting Videos 18.2.1 Cohort 1 18.2.2 Cohort 2 18.2.3 Cohort 3 18.2.4 Cohort 4 18.2.5 Cohort 5 18.2.6 Cohort 6 Meeting chat log LOG "],["quasiquotation.html", "Chapter 19 Quasiquotation", " Chapter 19 Quasiquotation Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-7.html", "19.1 SLIDE 1", " 19.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-18.html", "19.2 Meeting Videos", " 19.2 Meeting Videos 19.2.1 Cohort 1 19.2.2 Cohort 2 19.2.3 Cohort 3 19.2.4 Cohort 4 19.2.5 Cohort 5 19.2.6 Cohort 6 Meeting chat log LOG "],["evaluation.html", "Chapter 20 Evaluation", " Chapter 20 Evaluation Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-8.html", "20.1 SLIDE 1", " 20.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-19.html", "20.2 Meeting Videos", " 20.2 Meeting Videos 20.2.1 Cohort 1 20.2.2 Cohort 2 20.2.3 Cohort 3 20.2.4 Cohort 4 20.2.5 Cohort 5 20.2.6 Cohort 6 Meeting chat log LOG "],["translating-r-code.html", "Chapter 21 Translating R code", " Chapter 21 Translating R code Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-9.html", "21.1 SLIDE 1", " 21.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-20.html", "21.2 Meeting Videos", " 21.2 Meeting Videos 21.2.1 Cohort 1 21.2.2 Cohort 2 21.2.3 Cohort 3 (no video) 21.2.4 Cohort 4 21.2.5 Cohort 5 21.2.6 Cohort 6 Meeting chat log LOG "],["debugging.html", "Chapter 22 Debugging", " Chapter 22 Debugging Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-10.html", "22.1 SLIDE 1", " 22.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-21.html", "22.2 Meeting Videos", " 22.2 Meeting Videos 22.2.1 Cohort 1 22.2.2 Cohort 2 22.2.3 Cohort 3 22.2.4 Cohort 4 22.2.5 Cohort 5 22.2.6 Cohort 6 Meeting chat log LOG "],["measuring-performance.html", "Chapter 23 Measuring performance", " Chapter 23 Measuring performance Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-11.html", "23.1 SLIDE 1", " 23.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-22.html", "23.2 Meeting Videos", " 23.2 Meeting Videos 23.2.1 Cohort 1 (no video) 23.2.2 Cohort 2 23.2.3 Cohort 3 23.2.4 Cohort 4 23.2.5 Cohort 5 23.2.6 Cohort 6 Meeting chat log LOG "],["improving-performance.html", "Chapter 24 Improving performance", " Chapter 24 Improving performance Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-12.html", "24.1 SLIDE 1", " 24.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-23.html", "24.2 Meeting Videos", " 24.2 Meeting Videos 24.2.1 Cohort 1 (no video) 24.2.2 Cohort 2 24.2.3 Cohort 3 24.2.4 Cohort 4 24.2.5 Cohort 5 24.2.6 Cohort 6 Meeting chat log LOG "],["rewriting-r-code-in-c.html", "Chapter 25 Rewriting R code in C++", " Chapter 25 Rewriting R code in C++ Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-13.html", "25.1 SLIDE 1", " 25.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-24.html", "25.2 Meeting Videos", " 25.2 Meeting Videos 25.2.1 Cohort 1 25.2.2 Cohort 2 25.2.3 Cohort 3 25.2.4 Cohort 4 25.2.5 Cohort 5 25.2.6 Cohort 6 Meeting chat log LOG "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
